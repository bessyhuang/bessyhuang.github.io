<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/01/27/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Docker Storage</title>
    <url>/2025/07/15/Docker/Docker-Storage/</url>
    <content><![CDATA[<h1 id="Docker-Storage-Architecture（儲存架構）"><a href="#Docker-Storage-Architecture（儲存架構）" class="headerlink" title="Docker Storage Architecture（儲存架構）"></a>Docker Storage Architecture（儲存架構）</h1><h2 id="Layered-Architecture-分層架構"><a href="#Layered-Architecture-分層架構" class="headerlink" title="Layered Architecture (分層架構)"></a>Layered Architecture (分層架構)</h2><p>每個 Docker 容器都是由唯讀映像層（image layer）和一個可寫容器層（container layer）組成。</p>
<ul>
<li>Image Layers<ul>
<li>Read Only</li>
</ul>
</li>
<li>Container Layers<ul>
<li>Read Write</li>
<li>Copy-on-Write（寫入時複製）<blockquote>
<p>當容器對檔案進行修改時，Docker 並不會直接修改映像層(唯讀層)的檔案，而是複製該檔案到容器層(可寫層)再修改，這稱為 Copy-on-Write。<br>這樣可保持映像層不變，保證容器隔離性與一致性。</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="Storage-Drivers"><a href="#Storage-Drivers" class="headerlink" title="Storage Drivers"></a>Storage Drivers</h1><p>Docker 使用不同的儲存驅動來管理容器層的檔案系統。</p>
<blockquote>
<p>Overlay2 是目前最建議使用的主流驅動（除非有特別需求）。</p>
</blockquote>
<p>不同的作業系統與需求會對應不同的驅動：</p>
<ul>
<li><strong>AUFS</strong>（Ubuntu 常見，支援多層）</li>
<li><strong>Overlay &#x2F; Overlay2</strong>（現代 Linux 發行版的預設）</li>
<li><strong>ZFS</strong>（支援壓縮與快照）</li>
<li><strong>Btrfs</strong>（支援子卷與快照）</li>
<li><strong>Device Mapper</strong>（早期 CentOS &#x2F; RHEL 使用）</li>
<li><strong>VFS</strong>（開發&#x2F;除錯用途，不使用 Copy-on-Write）</li>
</ul>
<p>Overlay2 建議搭配 xfs 或 ext4 檔案系統，並支援 SELinux。<br>可以使用以下指令確認目前使用的 Storage Driver：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info | grep Storage</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Volume-Drivers"><a href="#Volume-Drivers" class="headerlink" title="Volume Drivers"></a>Volume Drivers</h1><p>Volume 是容器外部的持久化儲存方式，支援許多第三方儲存解決方案：</p>
<ul>
<li><strong>local</strong>（預設、儲存在本地 <code>/var/lib/docker/volumes</code>）</li>
<li><strong>Azure File Storage</strong></li>
<li><strong>DigitalOcean Block Storage</strong></li>
<li><strong>gce-docker</strong>（Google Cloud）</li>
<li><strong>GlusterFS</strong></li>
<li><strong>NetApp</strong></li>
<li><strong>Portworx</strong></li>
<li><strong>RexRay</strong>（支援 AWS EBS、EMC 等）</li>
<li><strong>Convoy</strong></li>
<li><strong>Flocker</strong></li>
<li><strong>VMware vSphere Storage</strong></li>
</ul>
<h2 id="使用-Volume-Driver-範例："><a href="#使用-Volume-Driver-範例：" class="headerlink" title="使用 Volume Driver 範例："></a>使用 Volume Driver 範例：</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">  --name mysql \</span><br><span class="line">  --volume-driver rexray/ebs \</span><br><span class="line">  --mount src=ebs-vol,target=/var/lib/mysql \</span><br><span class="line">  mysql</span><br></pre></td></tr></table></figure>

<h2 id="Volume-Driver-實務補充"><a href="#Volume-Driver-實務補充" class="headerlink" title="Volume Driver 實務補充"></a>Volume Driver 實務補充</h2><p>如何列出與移除 volume</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume <span class="built_in">ls</span></span><br><span class="line">docker volume inspect data_volume</span><br><span class="line">docker volume <span class="built_in">rm</span> data_volume</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Docker-Volumes（資料卷）"><a href="#Docker-Volumes（資料卷）" class="headerlink" title="Docker Volumes（資料卷）"></a>Docker Volumes（資料卷）</h1><h2 id="Volume-Mounting（資料卷掛載）"><a href="#Volume-Mounting（資料卷掛載）" class="headerlink" title="Volume Mounting（資料卷掛載）"></a>Volume Mounting（資料卷掛載）</h2><p>儲存於 <code>/var/lib/docker/volumes</code> 內部目錄，由 Docker 管理。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker volume create data_volume</span><br><span class="line">docker run -v data_volume:/var/lib/mysql mysql</span><br></pre></td></tr></table></figure>

<p>或用另一個 volume：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v data_volume2:/var/lib/mysql mysql</span><br></pre></td></tr></table></figure>

<h2 id="Bind-Mounting（目錄綁定掛載）"><a href="#Bind-Mounting（目錄綁定掛載）" class="headerlink" title="Bind Mounting（目錄綁定掛載）"></a>Bind Mounting（目錄綁定掛載）</h2><p>綁定主機檔案系統的特定目錄 (e.g. <code>/data</code>)，適合需要直接存取主機檔案的場景。</p>
<blockquote>
<p>⚠️ 使用 Bind Mount 時，要特別小心主機路徑的權限與 SELinux&#x2F;AppArmor 安全設定，以免造成容器存取主機敏感檔案。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -v /data/mysql:/var/lib/mysql mysql</span><br></pre></td></tr></table></figure>

<p>或使用 <code>--mount</code>（較新且推薦）語法：👍</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --mount <span class="built_in">type</span>=<span class="built_in">bind</span>,<span class="built_in">source</span>=/data/mysql,target=/var/lib/mysql mysql</span><br></pre></td></tr></table></figure>

<h2 id="差異比較"><a href="#差異比較" class="headerlink" title="差異比較"></a>差異比較</h2><table>
<thead>
<tr>
<th>項目</th>
<th>Volume Mount</th>
<th>Bind Mount</th>
</tr>
</thead>
<tbody><tr>
<td>定義方式</td>
<td>由 Docker 管理</td>
<td>綁定主機目錄</td>
</tr>
<tr>
<td>可攜性</td>
<td>高</td>
<td>低</td>
</tr>
<tr>
<td>安全性</td>
<td>高（Docker 控制）</td>
<td>較低（直接操作主機，主機目錄直接存取）</td>
</tr>
<tr>
<td>備份與復原</td>
<td>容易</td>
<td>需自定義腳本&#x2F;工具</td>
</tr>
<tr>
<td>SELinux 相容性</td>
<td>有良好支援</td>
<td>須手動調整對應標籤</td>
</tr>
</tbody></table>
<hr>
<h1 id="Container-Storage-Interface-CSI"><a href="#Container-Storage-Interface-CSI" class="headerlink" title="Container Storage Interface (CSI)"></a>Container Storage Interface (CSI)</h1><p>Container Storage Interface 是 K8s 等容器編排系統與儲存解決方案之間的標準接口協定，讓各種儲存供應商能以一致方式整合。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">      App (Pod)</span><br><span class="line">	  |</span><br><span class="line">	  v</span><br><span class="line">     [ Kubelet ]</span><br><span class="line">	  |</span><br><span class="line">	  v</span><br><span class="line">    [ CSI Plugin ]</span><br><span class="line">	  |</span><br><span class="line">	  v</span><br><span class="line">[ Storage Provider (e.g. AWS EBS, Ceph) ]</span><br></pre></td></tr></table></figure>

<h2 id="CSI-對應的容器接口"><a href="#CSI-對應的容器接口" class="headerlink" title="CSI 對應的容器接口"></a>CSI 對應的容器接口</h2><ul>
<li>CRI (Container Runtime Interface)：容器運行時介面，對接 Docker、containerd、CRI-O 等。</li>
<li>CNI (Container Network Interface)：容器網路介面，對接 Flannel、Cilium、Calico 等。</li>
<li>CSI (Container Storage Interface)：容器儲存介面，對接各種儲存供應商。<ul>
<li>常見支援 CSI 的儲存方案：<ul>
<li>AWS EBS</li>
<li>Azure Disk</li>
<li>Google Persistent Disk</li>
<li>Dell EMC</li>
<li>Portworx</li>
<li>GlusterFS</li>
<li>Ceph</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="CSI-功能要求"><a href="#CSI-功能要求" class="headerlink" title="CSI 功能要求"></a>CSI 功能要求</h2><table>
<thead>
<tr>
<th>功能</th>
<th>RPC 名稱</th>
<th>說明</th>
<th>執行端</th>
</tr>
</thead>
<tbody><tr>
<td>建立 Volume</td>
<td><code>CreateVolume</code></td>
<td>建立新的儲存資源（PV 對應）</td>
<td>Controller</td>
</tr>
<tr>
<td>刪除 Volume</td>
<td><code>DeleteVolume</code></td>
<td>刪除儲存資源</td>
<td>Controller</td>
</tr>
<tr>
<td>附加 Volume 到節點</td>
<td><code>ControllerPublishVolume</code></td>
<td>將 volume attach 至 node</td>
<td>Controller</td>
</tr>
<tr>
<td>從節點移除 Volume</td>
<td><code>ControllerUnpublishVolume</code></td>
<td>detach volume from node</td>
<td>Controller</td>
</tr>
<tr>
<td>掛載 Volume 給容器使用</td>
<td><code>NodePublishVolume</code></td>
<td>將 volume 掛載到節點目錄供 Pod 使用</td>
<td>Node</td>
</tr>
<tr>
<td>卸載 Volume</td>
<td><code>NodeUnpublishVolume</code></td>
<td>將 volume 從節點目錄卸載</td>
<td>Node</td>
</tr>
</tbody></table>
<h2 id="CSI-底層運作協定"><a href="#CSI-底層運作協定" class="headerlink" title="CSI 底層運作協定"></a>CSI 底層運作協定</h2><ul>
<li>使用 gRPC 與容器平台通訊<blockquote>
<p>CSI 使用 gRPC 作為通訊協定，能支援多語言、雙向串流與高效能序列化，適合跨平台的容器架構。</p>
</blockquote>
</li>
<li>定義 RPC 方法：CreateVolume、DeleteVolume、ControllerPublishVolume、NodePublishVolume 等</li>
</ul>
<h2 id="補充-CLI-工具與-YAML-例子（進入-Kubernetes-實作）"><a href="#補充-CLI-工具與-YAML-例子（進入-Kubernetes-實作）" class="headerlink" title="補充 CLI 工具與 YAML 例子（進入 Kubernetes 實作）"></a>補充 CLI 工具與 YAML 例子（進入 Kubernetes 實作）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PersistentVolumeClaim YAML 例子（K8s）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolumeClaim</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypvc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">storageClassName:</span> <span class="string">gp2</span></span><br><span class="line">  <span class="attr">resources:</span></span><br><span class="line">    <span class="attr">requests:</span></span><br><span class="line">      <span class="attr">storage:</span> <span class="string">5Gi</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PersistentVolume (PV) YAML 例子（K8s）</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">mypv</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">capacity:</span></span><br><span class="line">    <span class="attr">storage:</span> <span class="string">5Gi</span></span><br><span class="line">  <span class="attr">accessModes:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">ReadWriteOnce</span></span><br><span class="line">  <span class="attr">hostPath:</span></span><br><span class="line">    <span class="attr">path:</span> <span class="string">/data/mysql</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h1><table>
<thead>
<tr>
<th>功能</th>
<th>技術</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td>儲存格式</td>
<td>Copy-on-Write</td>
<td>容器層讀寫原理</td>
</tr>
<tr>
<td>儲存驅動</td>
<td>Overlay2 等</td>
<td>控制容器檔案系統</td>
</tr>
<tr>
<td>資料卷</td>
<td>Volume &#x2F; Bind Mount</td>
<td>持久化儲存</td>
</tr>
<tr>
<td>跨平台儲存</td>
<td>Volume Driver</td>
<td>整合外部儲存解決方案</td>
</tr>
<tr>
<td>標準儲存協定</td>
<td>CSI</td>
<td>容器與儲存供應商之間的接口</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Storage</tag>
      </tags>
  </entry>
  <entry>
    <title>從零開始學 Docker - 為何它這麼重要？(Part 1)</title>
    <url>/2024/01/30/Docker/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E5%AD%B8-Docker-%E7%82%BA%E4%BD%95%E5%AE%83%E9%80%99%E9%BA%BC%E9%87%8D%E8%A6%81%EF%BC%9F-Part-1/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker 的三大功用：</span><br><span class="line">1. 簡化部署流程</span><br><span class="line">2. 跨平台部署</span><br><span class="line">3. 建立乾淨測試環境</span><br></pre></td></tr></table></figure>

<h1 id="功用一：簡化部署流程"><a href="#功用一：簡化部署流程" class="headerlink" title="功用一：簡化部署流程"></a>功用一：簡化部署流程</h1><h2 id="觀念解說"><a href="#觀念解說" class="headerlink" title="觀念解說"></a>觀念解說</h2><p>如果沒有使用 Docker，當你需要將應用程式部署到多台伺服器上時，必須逐一輸入指令進行設定。這不僅在環境安裝階段耗費大量時間且枯燥乏味，還容易因人為失誤而輸入錯誤指令。更重要的是，若需要在不同環境中進行部署，還得應對各種環境變數和配置的複雜性。</p>
<p>Docker 的推出為我們提供了一套強大的容器化解決方案。</p>
<p>透過使用 Docker，我們能夠將應用程式及其相依的環境、套件等打包成一個獨立、可攜帶的容器。這樣一來，無論在何處都能確保應用程式以相同的方式運行，避免受到不同環境的影響。</p>
<p>這種容器化的方法使得應用程式的部署和管理變得更加靈活、簡便，同時提供了更高度的一致性和可攜性。</p>
<hr>
<h1 id="實作示範"><a href="#實作示範" class="headerlink" title="實作示範"></a>實作示範</h1><h2 id="建立一個映像檔（Docker-Image）"><a href="#建立一個映像檔（Docker-Image）" class="headerlink" title="建立一個映像檔（Docker Image）"></a>建立一個映像檔（Docker Image）</h2><p>Docker Image 就像是一個獨立、可攜帶的程式部署包，其中包含了應用程式（在這個範例中是 Django 網站）以及它所需要的環境、套件等資源，都被一併打包在一起。</p>
<h3 id="Start-a-Docker-Container"><a href="#Start-a-Docker-Container" class="headerlink" title="Start a Docker Container"></a>Start a Docker Container</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker pull python:3.12-alpine</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name mysite -it -p 8000:8000 python:3.12-alpine /bin/sh</span></span><br><span class="line">/ #</span><br></pre></td></tr></table></figure>

<h3 id="Install-packages-in-a-Docker-Container"><a href="#Install-packages-in-a-Docker-Container" class="headerlink" title="Install packages in a Docker Container"></a>Install packages in a Docker Container</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/ # apk update</span><br><span class="line">/ # apk add vim</span><br><span class="line">/ # pip install django</span><br></pre></td></tr></table></figure>

<h3 id="Create-a-Django-website-in-a-Docker-Container"><a href="#Create-a-Django-website-in-a-Docker-Container" class="headerlink" title="Create a Django website in a Docker Container"></a>Create a Django website in a Docker Container</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/     # cd /home/</span><br><span class="line">/home # django-admin startproject mysite</span><br><span class="line">/home # cd mysite/</span><br><span class="line">/home/mysite # django-admin startapp app1</span><br></pre></td></tr></table></figure>

<h3 id="Django-Settings"><a href="#Django-Settings" class="headerlink" title="Django Settings"></a>Django Settings</h3><ul>
<li><code>mysite/settings.py</code>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">       <span class="comment">#...</span></span><br><span class="line">       <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><code>mysite/urls.py</code>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path <span class="keyword">as</span> url</span><br><span class="line"><span class="keyword">from</span> app1.views <span class="keyword">import</span> hello_world</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">       <span class="comment">#...</span></span><br><span class="line">       url(<span class="string">r&#x27;^hello/$&#x27;</span>, hello_world),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li>
<li><code>app1/views.py</code>  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">       <span class="keyword">return</span> HttpResponse(<span class="string">&#x27;Hello, World.&#x27;</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="Run-a-Django-website-in-a-Docker-Container"><a href="#Run-a-Django-website-in-a-Docker-Container" class="headerlink" title="Run a Django website in a Docker Container"></a>Run a Django website in a Docker Container</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">/home/mysite # python manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Open your browser: <a href="http://localhost:8000/hello/">http://localhost:8000/hello/</a></p>
<img src="/2024/01/30/Docker/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E5%AD%B8-Docker-%E7%82%BA%E4%BD%95%E5%AE%83%E9%80%99%E9%BA%BC%E9%87%8D%E8%A6%81%EF%BC%9F-Part-1/hello_world.jpg" class="" title="Hello, World.">
</blockquote>
<h3 id="Create-a-new-image-from-a-container’s-changes"><a href="#Create-a-new-image-from-a-container’s-changes" class="headerlink" title="Create a new image from a container’s changes"></a>Create a new image from a container’s changes</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker container <span class="built_in">ls</span> -a</span></span><br><span class="line">CONTAINER ID   IMAGE                COMMAND     CREATED          STATUS                      PORTS     NAMES</span><br><span class="line">dbd03d68bf0d   python:3.12-alpine   &quot;/bin/sh&quot;   32 minutes ago   Exited (0) 10 seconds ago             mysite</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker commit dbd03d68bf0d  django_site:v1</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker images</span></span><br><span class="line">REPOSITORY    TAG           IMAGE ID       CREATED         SIZE</span><br><span class="line">django_site   v1            5499518614d6   2 seconds ago   136MB</span><br><span class="line">python        3.12-alpine   d2cfe5300063   5 weeks ago     56.4MB</span><br></pre></td></tr></table></figure>

<h2 id="部署一個-Django-網站"><a href="#部署一個-Django-網站" class="headerlink" title="部署一個 Django 網站"></a>部署一個 Django 網站</h2><h3 id="Use-a-Docker-Image-to-create-a-Docker-Container"><a href="#Use-a-Docker-Image-to-create-a-Docker-Container" class="headerlink" title="Use a Docker Image to create a Docker Container"></a>Use a Docker Image to create a Docker Container</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run --name mysite_002 -it -p 8000:8000 django_site:v1 /bin/sh</span></span><br><span class="line">/ # cd home/mysite/</span><br><span class="line">/home/mysite # python manage.py runserver 0.0.0.0:8000</span><br></pre></td></tr></table></figure>

<blockquote>
<p>哇！只要三行指令，就能把事先打包好的 Django 網站建立起來了～<br>Open your browser: <a href="http://localhost:8000/hello/">http://localhost:8000/hello/</a><br>PS. 後續還有更進階的部署作法，像是 Dockerfile、Docker Compose 喔！</p>
</blockquote>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>觀念解說</tag>
      </tags>
  </entry>
  <entry>
    <title>從零開始學 Docker - 為何它這麼重要？(Part 2)</title>
    <url>/2024/02/04/Docker/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E5%AD%B8-Docker-%E7%82%BA%E4%BD%95%E5%AE%83%E9%80%99%E9%BA%BC%E9%87%8D%E8%A6%81%EF%BC%9F-Part-2/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker 的三大功用：</span><br><span class="line">1. 簡化部署流程</span><br><span class="line">2. 跨平台部署</span><br><span class="line">3. 建立乾淨測試環境</span><br></pre></td></tr></table></figure>

<h1 id="功用二：跨平台部署"><a href="#功用二：跨平台部署" class="headerlink" title="功用二：跨平台部署"></a>功用二：跨平台部署</h1><h2 id="觀念解說"><a href="#觀念解說" class="headerlink" title="觀念解說"></a>觀念解說</h2><p>Docker 的強大功能之一是「跨平台部署」！透過把程式及其相依的環境、套件打包成 Docker Image（aka. 程式部署包），你可以輕鬆地在不同作業系統上（Linux、MacOS 或 Windows）運行你的應用程式。</p>
<p>完成 Docker Image 的製作後，成功上傳至 Docker Hub（aka. 存放 Docker Image 的雲端空間），使其他使用者能夠在全球的任何地方、任何作業系統上輕鬆進行下載。隨後，透過在各自作業系統上安裝 Docker Engine，可以協調作業系統與 Docker 容器之間的運行，而無需擔心環境相容性問題。</p>
<p>簡言之，Docker 讓跨平台部署變得快速、便捷，確保了一致的部署體驗。</p>
<hr>
<h1 id="實作示範"><a href="#實作示範" class="headerlink" title="實作示範"></a>實作示範</h1><p>本章節示範內容：部署一個 Django Website 於不同作業系統上。<br>藉由撰寫 Dockerfile 來建立 Docker Image，並且將製作好的 Docker Image 上傳至 Docker Hub，以便進行跨平台部署。</p>
<h2 id="準備-Django-Website"><a href="#準備-Django-Website" class="headerlink" title="準備 Django Website"></a>準備 Django Website</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">django-admin startproject mysite</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> mysite</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">django-admin startapp app1</span></span><br></pre></td></tr></table></figure>

<p>網站的階層架構，如下所示。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">└── mysite/</span><br><span class="line">    ├── app1/</span><br><span class="line">    │   ├── __init__.py</span><br><span class="line">    │   ├── admin.py</span><br><span class="line">    │   ├── apps.py</span><br><span class="line">    │   ├── models.py</span><br><span class="line">    │   ├── tests.py</span><br><span class="line">    │   └── views.py</span><br><span class="line">    ├── manage.py</span><br><span class="line">    └── mysite/</span><br><span class="line">        ├── __init__.py</span><br><span class="line">        ├── asgi.py</span><br><span class="line">        ├── settings.py</span><br><span class="line">        ├── urls.py</span><br><span class="line">        └── wsgi.py</span><br></pre></td></tr></table></figure>

<h3 id="mysite-settings-py"><a href="#mysite-settings-py" class="headerlink" title="mysite&#x2F;settings.py"></a>mysite&#x2F;settings.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="string">&#x27;app1&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="mysite-urls-py"><a href="#mysite-urls-py" class="headerlink" title="mysite&#x2F;urls.py"></a>mysite&#x2F;urls.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> re_path</span><br><span class="line"><span class="keyword">from</span> app1.views <span class="keyword">import</span> hello_world</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    re_path(<span class="string">r&#x27;^hello/$&#x27;</span>, hello_world),</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h3 id="app1-views-py"><a href="#app1-views-py" class="headerlink" title="app1&#x2F;views.py"></a>app1&#x2F;views.py</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#...</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">hello_world</span>(<span class="params">request</span>):</span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello, World!&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2 id="撰寫-Dockerfile"><a href="#撰寫-Dockerfile" class="headerlink" title="撰寫 Dockerfile"></a>撰寫 Dockerfile</h2><p>Dockerfile 是用於建置 Docker Image 的腳本。</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.10</span>-alpine</span><br><span class="line"><span class="keyword">ENV</span> myworkdir /home/django_site</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> <span class="variable">$&#123;myworkdir&#125;</span></span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./mysite/ <span class="variable">$&#123;myworkdir&#125;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk update</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apk add vim</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> pip install django</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;manage.py&quot;</span>, <span class="string">&quot;runserver&quot;</span>, <span class="string">&quot;0.0.0.0:8000&quot;</span>]</span></span><br></pre></td></tr></table></figure>

<h2 id="建立-Docker-Image"><a href="#建立-Docker-Image" class="headerlink" title="建立 Docker Image"></a>建立 Docker Image</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">└── site/</span><br><span class="line">   ├── Dockerfile</span><br><span class="line">   └── mysite/</span><br><span class="line">        ├── app1/</span><br><span class="line">        │    ├── ...</span><br><span class="line">        ├── manage.py</span><br><span class="line">        └── mysite/</span><br><span class="line">             ├── ...</span><br></pre></td></tr></table></figure>

<p>cd 到有 <code>Dockerfile</code> 的目錄下。接著，建立名為 <code>django_site</code> 的 Docker Image。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> site/</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker build -t bessyhuang/django_site . --no-cache</span></span><br></pre></td></tr></table></figure>

<h2 id="執行"><a href="#執行" class="headerlink" title="執行"></a>執行</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d -p 8001:8000 django_site</span> </span><br></pre></td></tr></table></figure>
<p>打開瀏覽器 <a href="http://localhost:8001/hello/">http://localhost:8001/hello/</a></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>觀念解說</tag>
      </tags>
  </entry>
  <entry>
    <title>從零開始學 Docker - 為何它這麼重要？(Part 3)</title>
    <url>/2024/04/02/Docker/%E5%BE%9E%E9%9B%B6%E9%96%8B%E5%A7%8B%E5%AD%B8-Docker-%E7%82%BA%E4%BD%95%E5%AE%83%E9%80%99%E9%BA%BC%E9%87%8D%E8%A6%81%EF%BC%9F-Part-3/</url>
    <content><![CDATA[<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Docker 的三大功用：</span><br><span class="line">1. 簡化部署流程</span><br><span class="line">2. 跨平台部署</span><br><span class="line">3. 建立乾淨測試環境</span><br></pre></td></tr></table></figure>

<h1 id="功用三：建立乾淨測試環境"><a href="#功用三：建立乾淨測試環境" class="headerlink" title="功用三：建立乾淨測試環境"></a>功用三：建立乾淨測試環境</h1><h2 id="觀念解說"><a href="#觀念解說" class="headerlink" title="觀念解說"></a>觀念解說</h2><hr>
<h1 id="實作示範"><a href="#實作示範" class="headerlink" title="實作示範"></a>實作示範</h1><p>本章節示範內容：建立乾淨的測試環境。<br>利用 Dockerfile 建立一份客製映像檔（Docker Image），並把測試環境跑起來。</p>
<h2 id="準備-MongoDB-Container"><a href="#準備-MongoDB-Container" class="headerlink" title="準備 MongoDB Container"></a>準備 MongoDB Container</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker network create test_network</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -d --name mongodb --network test_network bessyhuang/py3.10_mongo:v1</span> </span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker <span class="built_in">exec</span> -it mongodb bash</span></span><br></pre></td></tr></table></figure>

<h2 id="準備-Django-Platform-Container"><a href="#準備-Django-Platform-Container" class="headerlink" title="準備 Django Platform Container"></a>準備 Django Platform Container</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">docker run -it -p 8001:8000 -v /Users/bessyhuang/Downloads/TEST_mysite/esiot-platform:/home/ --network test_network --name podman_platform python:3.11.8-slim bash</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt update</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">apt install gcc python3-dev -y</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">pip install -r py3.11.8_requirements.txt</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">python manage.py runserver 0.0.0.0:8000</span></span><br></pre></td></tr></table></figure>



<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> python:<span class="number">3.11</span>.<span class="number">8</span>-slim</span><br><span class="line"><span class="keyword">MAINTAINER</span> Bessy</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"> ./mysite ./home/</span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"> /home/mysite</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> apt-get update &amp;&amp; apt-get install iproute2 -y &amp;&amp; apt-get install vim -y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8000</span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> [<span class="string">&quot;python&quot;</span>, <span class="string">&quot;manage.py&quot;</span>, <span class="string">&quot;runserver&quot;</span>]</span></span><br></pre></td></tr></table></figure>


<p>Example</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM alpine:latest</span><br><span class="line">ENV myworkdir /var/www/localhost/htdocs/</span><br><span class="line">ARG whoami=Bessy</span><br><span class="line">WORKDIR $&#123;myworkdir&#125;</span><br><span class="line">RUN apk --update add apache2</span><br><span class="line">RUN rm -rf /var/cache/apk/*</span><br><span class="line">RUN echo &quot;&lt;h3&gt;I am $&#123;whoami&#125;. I am taking this great Docker Course. Round 01&lt;/h3&gt;&quot; &gt;&gt; index.html</span><br><span class="line">RUN echo &quot;&lt;h3&gt;I am $&#123;whoami&#125;. I am taking this great Docker Course. Round 02&lt;/h3&gt;&quot; &gt;&gt; index.html</span><br><span class="line">RUN echo &quot;&lt;h3&gt;I am $&#123;whoami&#125;. I am taking this great Docker Course. Round 03&lt;/h3&gt;&quot; &gt;&gt; index.html</span><br><span class="line">COPY ./content.txt ./</span><br><span class="line">RUN ls -l ./</span><br><span class="line">RUN cat ./content.txt &gt;&gt; index.html</span><br><span class="line">ENTRYPOINT [&quot;httpd&quot;, &quot;-D&quot;, &quot;FOREGROUND&quot;]</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>觀念解說</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo | Getting Started</title>
    <url>/2024/03/18/Hexo-Getting-Started/</url>
    <content><![CDATA[<h1 id="建立一個新的-Hexo-網站"><a href="#建立一個新的-Hexo-網站" class="headerlink" title="建立一個新的 Hexo 網站"></a>建立一個新的 Hexo 網站</h1><h2 id="安裝套件"><a href="#安裝套件" class="headerlink" title="安裝套件"></a>安裝套件</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-cli -g</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install -g npm@10.5.0</span></span><br></pre></td></tr></table></figure>

<ul>
<li>如果要把 Hexo deploy 到 Github 上面，需要先安裝 <code>hexo-deployer-git</code>。<ul>
<li>相關設定，請參考 <a href="https://ithelp.ithome.com.tw/articles/10257569">建立自己Blog系列(三) Hexo next theme 介紹</a>。</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install hexo-deployer-git --save</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">nano _config.yml</span></span><br></pre></td></tr></table></figure>

<h2 id="網站初始化"><a href="#網站初始化" class="headerlink" title="網站初始化"></a>網站初始化</h2><p>如果沒有設定 folder 的話，Hexo 會在目前的資料夾建立網站。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo init myblog</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> myblog/</span></span><br></pre></td></tr></table></figure>

<h2 id="新增一篇-Post"><a href="#新增一篇-Post" class="headerlink" title="新增一篇 Post"></a>新增一篇 Post</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo new <span class="string">&quot;Hexo | Getting Started&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">vim <span class="built_in">source</span>/_posts/Hexo-Getting-Started.md</span></span><br></pre></td></tr></table></figure>

<h2 id="啟動伺服器"><a href="#啟動伺服器" class="headerlink" title="啟動伺服器"></a>啟動伺服器</h2><p>預設是 <a href="http://localhost:4000/">http://localhost:4000/</a></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo server</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo s</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="部署三部曲"><a href="#部署三部曲" class="headerlink" title="部署三部曲"></a>部署三部曲</h1><ol>
<li><p>清除快取檔案 (db.json) 和已產生的靜態檔案 (public)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo clean</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo cl</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>產生靜態檔案 (部署網站前先產生靜態檔案)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo generate</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo g</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>部署網站</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo deploy</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo d</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="Clone-Run-your-Repository"><a href="#Clone-Run-your-Repository" class="headerlink" title="Clone &amp; Run your Repository"></a>Clone &amp; Run your Repository</h1><h2 id="Repository-跑起來"><a href="#Repository-跑起來" class="headerlink" title="Repository 跑起來"></a>Repository 跑起來</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git <span class="built_in">clone</span> https://github.com/bessyhuang/bessyhuang.github.io.git</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash"><span class="built_in">cd</span> bessyhuang.github.io/</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout backup</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">npm install</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">hexo server</span></span><br></pre></td></tr></table></figure>

<h2 id="備份於-GitHub-Repository-的-backup-分支"><a href="#備份於-GitHub-Repository-的-backup-分支" class="headerlink" title="備份於 GitHub Repository 的 backup 分支"></a>備份於 GitHub Repository 的 <code>backup 分支</code></h2><ul>
<li>git checkout<ul>
<li>切換分支。Switch branches or restore working tree files</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git checkout backup</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git add --all</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git commit -m <span class="string">&quot;New function or something modified&quot;</span></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">git push --set-upstream origin backup</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://hexo.io/zh-tw/docs/commands.html">Hexo 指令</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10257569">建立自己Blog系列(三) Hexo next theme 介紹</a></li>
<li><a href="https://ithelp.ithome.com.tw/articles/10308093">CI&#x2F;CD X Jenkins、CircleCI、Github Action (28)</a></li>
<li><a href="https://blog.marsen.me/2022/09/26/2022/Hexo_CICD/">[實作筆記] Hexo CI&#x2F;CD 設置</a></li>
<li><a href="https://anemology.cc/post/hexo-backup/">Hexo 備份至 GitHub</a></li>
<li><a href="https://afun.tw/blog/20201114-hexo-init-github-page/">Hexo - 基本設定與 GitHub Page 發佈流程</a></li>
<li><a href="https://op30132.github.io/2019/12/24/hexo-tag-page/">hexo 新增 tag、catagories、about等頁面</a></li>
</ul>
]]></content>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Django</title>
    <url>/2023/08/16/TempNotes/Django/</url>
    <content><![CDATA[<blockquote>
<p><em>“Django makes it easier to build better web apps more quickly and with less code.” — Django Official Website</em></p>
</blockquote>
<h1 id="Intro"><a href="#Intro" class="headerlink" title="Intro"></a>Intro</h1><p>Django is a high-level Python web framework that encourages rapid development and clean, pragmatic design. It’s free and open source.</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1>]]></content>
      <tags>
        <tag>Django</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Visualization - Advanced</title>
    <url>/2023/08/12/TempNotes/Data-Visualization-Advanced/</url>
    <content><![CDATA[<h1 id="Common-Data-Visualization-Mistakes"><a href="#Common-Data-Visualization-Mistakes" class="headerlink" title="Common Data Visualization Mistakes"></a>Common Data Visualization Mistakes</h1><h2 id="1-Misleading-color-contrast"><a href="#1-Misleading-color-contrast" class="headerlink" title="1. Misleading color contrast"></a>1. Misleading color contrast</h2><p>Although using various colors aids in interpreting data visualizations, too much color can confuse the user.<br>It’s crucial to stick to a limited number of unique colors.<br><img src="https://miro.medium.com/v2/resize:fit:1400/0*jl2BBj1gHt3qoTXU" alt="Bad Example: Misleading color contrast"></p>
<ul>
<li>Solution<ul>
<li>The simplest way to determine contrast value is to compare contrast colors on greyscale to check if the color you choose displays the difference.<br><img src="https://miro.medium.com/v2/resize:fit:1400/0*M_5cpWpvfNJzVsqQ"></li>
</ul>
</li>
</ul>
<h2 id="2-Overwhelming-charts-with-too-much-data"><a href="#2-Overwhelming-charts-with-too-much-data" class="headerlink" title="2. Overwhelming charts with too much data"></a>2. Overwhelming charts with too much data</h2><p><img src="https://miro.medium.com/v2/resize:fit:1400/0*wzDTQBW8wYIev4GC" alt="Bad Example: Overwhelming charts with too much data"></p>
<ul>
<li>Solution<ul>
<li>Do not put all of your insights into a chart. Multiple visualizations can help you communicate data more effectively.</li>
<li>It is recommended that no more than 5–6 colors be used in a single visualization.</li>
</ul>
</li>
</ul>
<h2 id="3-Omitting-baseline-and-truncating-scale"><a href="#3-Omitting-baseline-and-truncating-scale" class="headerlink" title="3. Omitting baseline and truncating scale"></a>3. Omitting baseline and truncating scale</h2><img src="/2023/08/12/TempNotes/Data-Visualization-Advanced/Omitting_baseline_and_truncating_scale.jpg" class="" title="Bad Example: Omitting baseline and truncating scale">

<ul>
<li>Solution<ul>
<li>Concentrate on creating data visualizations with a zero-baseline y-axis.</li>
<li>If removing the zero makes sense, add a zero-break to communicate that.<img src="/2023/08/12/TempNotes/Data-Visualization-Advanced/solution_Omitting_baseline_and_truncating_scale.jpg" class=""></li>
</ul>
</li>
</ul>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ol>
<li><a href="https://flourish.studio/blog/common-mistakes-in-data-visualization/">Four data visualization mistakes you’re probably making and how to fix them</a></li>
<li><a href="https://www.toptal.com/designers/ux/data-visualization-mistakes">Numbers Shouldn’t Lie: An Overview of Common Data Visualization Mistakes</a></li>
<li><a href="https://chartio.com/learn/charts/how-to-choose-data-visualization/">How to Choose the Right Data Visualization</a></li>
<li><a href="https://careerfoundry.com/en/tutorials/data-analytics-for-beginners/introduction-to-data-visualization/">Tutorial 4: An Introduction to Data Visualization</a></li>
</ol>
]]></content>
      <tags>
        <tag>Data Visualization</tag>
        <tag>Common Mistakes</tag>
      </tags>
  </entry>
  <entry>
    <title>Data Visualization - Basics</title>
    <url>/2023/08/03/TempNotes/Data-Visualization-Basics/</url>
    <content><![CDATA[<h1 id="What-is-data-visualization"><a href="#What-is-data-visualization" class="headerlink" title="What is data visualization?"></a>What is data visualization?</h1><h2 id="Definition"><a href="#Definition" class="headerlink" title="Definition"></a>Definition</h2><p>Data visualization (資料視覺化) is the graphical or visual representation of data.<br>It helps to highlight the most useful insights from a dataset, making it easier to spot trends, patterns, outliers, and correlations.</p>
<hr>
<h1 id="Two-main-types-of-data-visualization"><a href="#Two-main-types-of-data-visualization" class="headerlink" title="Two main types of data visualization"></a>Two main types of data visualization</h1><h2 id="1-Exploration"><a href="#1-Exploration" class="headerlink" title="1. Exploration"></a>1. Exploration</h2><p><em><font color=royalblue>Exploration takes place while you’re still analyzing the data.</font></em></p>
<ul>
<li>When faced with a new dataset, one of the first things you’ll do!</li>
<li>It helps you figure out what’s in your data.<ul>
<li>Get a sense of what’s in your dataset and to spot any noteworthy trends or anomalies. </li>
<li>Finding clues as to what the data might be trying to tell you.</li>
</ul>
</li>
</ul>
<h2 id="2-Explanation"><a href="#2-Explanation" class="headerlink" title="2. Explanation"></a>2. Explanation</h2><p><em><font color=royalblue>Explanatory visualization helps you to communicate what you’ve found.</font></em></p>
<ul>
<li>Once you’ve conducted your analysis and have figured out what the data is telling you, you’ll want to share these insights with others.</li>
<li>Help you tell the story, and it’s up to you to determine which visualizations will help you to do so most effectively.</li>
</ul>
<hr>
<h1 id="Five-types-of-data-visualization"><a href="#Five-types-of-data-visualization" class="headerlink" title="Five types of data visualization"></a>Five types of data visualization</h1><h2 id="1-Temporal-data-visualizations"><a href="#1-Temporal-data-visualizations" class="headerlink" title="1. Temporal data visualizations"></a>1. Temporal data visualizations</h2><ul>
<li>Linear and one-dimensional</li>
<li>e.g. scatterplots, timelines, line graphs</li>
</ul>
<img src="/2023/08/03/TempNotes/Data-Visualization-Basics/Temporal_data_viz.jpg" class="" title="Temporal data visualizations">

<h2 id="2-Hierarchical-visualizations"><a href="#2-Hierarchical-visualizations" class="headerlink" title="2. Hierarchical visualizations"></a>2. Hierarchical visualizations</h2><ul>
<li>Organize groups within larger groups</li>
<li>Often used to display clusters of information</li>
<li>e.g. tree diagrams, ring charts, sunburst diagrams</li>
</ul>
<img src="/2023/08/03/TempNotes/Data-Visualization-Basics/Hierarchical_viz.jpg" class="" title="Hierarchical visualizations">

<h2 id="3-Network-visualizations"><a href="#3-Network-visualizations" class="headerlink" title="3. Network visualizations"></a>3. Network visualizations</h2><ul>
<li>Show the relationships and connections between multiple datasets</li>
<li>e.g. matrix charts, word clouds, node-link diagrams</li>
</ul>
<img src="/2023/08/03/TempNotes/Data-Visualization-Basics/Network_viz.jpg" class="" title="Network visualizations">

<h2 id="4-Multidimensional-or-3D-visualizations"><a href="#4-Multidimensional-or-3D-visualizations" class="headerlink" title="4. Multidimensional or 3D visualizations"></a>4. Multidimensional or <a href="https://plotly.com/python/3d-charts/">3D visualizations</a></h2><ul>
<li>Depict two or more variables</li>
<li>e.g. pie charts, Venn diagrams, stacked bar graphs, histograms</li>
</ul>
<img src="/2023/08/03/TempNotes/Data-Visualization-Basics/Multidimensional_viz.jpg" class="" title="Multidimensional visualizations">

<h2 id="5-Geospatial-visualizations"><a href="#5-Geospatial-visualizations" class="headerlink" title="5. Geospatial visualizations"></a>5. Geospatial visualizations</h2><ul>
<li>Convey various data points in relation to physical, real-world locations</li>
<li>e.g. heat maps, cartograms, density maps</li>
</ul>
<img src="/2023/08/03/TempNotes/Data-Visualization-Basics/Geospatial_viz.jpg" class="" title="Geospatial visualizations">

<hr>
<h1 id="Popular-Python-Libraries-For-Data-Visualization"><a href="#Popular-Python-Libraries-For-Data-Visualization" class="headerlink" title="Popular Python Libraries For Data Visualization"></a>Popular Python Libraries For Data Visualization</h1><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a><a href="https://matplotlib.org/">Matplotlib</a></h2><p>Matplotlib is an easy-to-use Python library for data visualization which is built on top of NumPy arrays.<br>It is a low-level module and provides a lot of flexibility but at the cost of writing more code. </p>
<h2 id="Seaborn"><a href="#Seaborn" class="headerlink" title="Seaborn"></a><a href="https://seaborn.pydata.org/">Seaborn</a></h2><p>Seaborn is a high-level library built on the top of Matplotlib which means that it can also use Matplotlib functions and classes.<br>This library provides default styles and color palettes to make a plot more attractive.</p>
<h2 id="Plotly"><a href="#Plotly" class="headerlink" title="Plotly"></a><a href="https://plotly.com/python/">Plotly</a></h2><p>Plotly has hover tool capabilities that allow us to detect any outliers or anomalies in a large number of data points.<br>It is visually attractive that can be accepted by a wide range of audiences.<br>It allows us for the endless customization of our graphs that makes our plot more meaningful and understandable for others.</p>
<h2 id="Other-Popular-Python-Libraries"><a href="#Other-Popular-Python-Libraries" class="headerlink" title="Other Popular Python Libraries"></a>Other Popular Python Libraries</h2><ul>
<li>Altair</li>
<li>Bokeh</li>
<li>Folium</li>
<li>Diagrams</li>
<li>Wordcloud</li>
<li>…</li>
</ul>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://careerfoundry.com/en/blog/data-analytics/what-is-data-visualization/">What Is Data Visualization and Why Is It Important? A Complete Introduction</a></li>
<li><a href="https://www.geeksforgeeks.org/python-data-visualization-tutorial/">Python – Data visualization tutorial</a></li>
</ul>
]]></content>
      <tags>
        <tag>Data Visualization</tag>
        <tag>Introduction</tag>
      </tags>
  </entry>
  <entry>
    <title>MQTT vs. Redis vs. Kafka</title>
    <url>/2024/03/18/TempNotes/MQTT-vs-Redis-vs-Kafka/</url>
    <content><![CDATA[<h1 id="MQTT"><a href="#MQTT" class="headerlink" title="MQTT"></a>MQTT</h1><blockquote>
<p>Message Queueing Telemetry Transport</p>
</blockquote>
<p>It is a lightweight communication protocol for IoT devices and networks. MQTT is well-suited for use in low-bandwidth, high-latency networks, and is often used for real-time data transfer in applications such as home automation and energy management.</p>
<p>MQTT (Message Queuing Telemetry Transport) is a publish&#x2F;subscribe messaging protocol designed for resource-constrained devices and low-bandwidth networks. It provides a lightweight and efficient messaging infrastructure for microservices, making it ideal for IoT and mobile applications.</p>
<ul>
<li>物聯網(IoT) 通訊協議，專為資源受限的設備設計，提供了可靠的、有序的、低延遲的訊息傳輸</li>
<li>適用於物聯網設備間的訊息通訊</li>
</ul>
<h2 id="Advantages"><a href="#Advantages" class="headerlink" title="Advantages"></a>Advantages</h2><ol>
<li>Lightweight and efficient</li>
<li>Ideal for IoT and mobile applications</li>
<li>Publish&#x2F;subscribe model for easy scalability</li>
<li>Widely supported and well-documented API</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Quality of Service (QoS)</span><br><span class="line">Retained Messages</span><br><span class="line">Last Will and Testament (LWT)</span><br><span class="line"></span><br><span class="line">Scalability and Reliability</span><br></pre></td></tr></table></figure>

<h2 id="Disadvantages"><a href="#Disadvantages" class="headerlink" title="Disadvantages"></a>Disadvantages</h2><ol>
<li>Limited security options compared to other protocols</li>
<li>May not be suitable for high-volume or complex data transfers</li>
</ol>
<h2 id="Best-Use-Case"><a href="#Best-Use-Case" class="headerlink" title="Best Use Case"></a>Best Use Case</h2><p>MQTT is best for low-volume, resource-constrained, and scalable communication between microservices, especially in IoT and mobile applications.<br>It’s well-suited for environments with limited bandwidth or unreliable networks, and devices with low computational resources.</p>
<p>Choose: You need to ensure message delivery over unreliable or bandwidth-constrained networks. You are dealing with a large number of distributed devices or sensors.</p>
<hr>
<h1 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h1><blockquote>
<p>Remote Dictionary Server</p>
</blockquote>
<p>It is an in-memory data structure store that can be used as a database, cache, and message broker. Redis can be used for real-time communication between services, where messages are stored and retrieved using Redis pub&#x2F;sub.</p>
<p>Redis is an open-source, in-memory data structure store that can be used as a database, cache, and message broker. It provides fast and flexible access to data, making it well-suited for use as a cache and message broker in microservices.</p>
<ul>
<li>適用於需要高效能、在短時間內處理大量訊息的場景</li>
</ul>
<h2 id="Advantages-1"><a href="#Advantages-1" class="headerlink" title="Advantages"></a>Advantages</h2><ol>
<li>Fast in-memory access to data</li>
<li>Flexible data storage options</li>
<li>Publish&#x2F;subscribe model for easy scalability</li>
<li>Widely supported and well-documented API</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">high performance and low latency (Performance: Excellent for high-performance computing scenarios where rapid access to data is required.)</span><br><span class="line"></span><br><span class="line">Pub/Sub System</span><br><span class="line">Data Persistence</span><br><span class="line">Advanced Data Structures</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="Disadvantages-1"><a href="#Disadvantages-1" class="headerlink" title="Disadvantages"></a>Disadvantages</h2><ol>
<li>Limited durability compared to other protocols</li>
<li>May not be suitable for high-volume or complex data transfers</li>
<li>May require additional setup and configuration</li>
</ol>
<h2 id="Best-Use-Case-1"><a href="#Best-Use-Case-1" class="headerlink" title="Best Use Case"></a>Best Use Case</h2><p>Redis is best for fast, flexible, and scalable communication between microservices, especially as a cache or message broker.<br>It is also used for message brokering but in more data-centric applications like web applications, gaming, and real-time analytics.</p>
<p>Choose: You are developing applications that need rapid access to data with minimal latency. Your use case involves real-time analytics, gaming, or session management in web applications.</p>
<hr>
<h1 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h1><hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://blog.nonstopio.com/comparison-of-tcp-rmq-mqtt-redis-and-grpc-transport-layers-in-nest-js-microservices-2c10a2a98a6f">Comparison of TCP, (RMQ), MQTT, Redis, and gRPC transport layers in Nest.js microservices</a></li>
</ul>
]]></content>
      <categories>
        <category>Pub/Sub Messaging</category>
      </categories>
      <tags>
        <tag>MQTT</tag>
        <tag>Redis</tag>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>Amazon S3</title>
    <url>/2023/10/02/TempNotes/Amazon-S3/</url>
    <content><![CDATA[<h1 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h1><p><em><font color=royalblue>Infinitely Scaling Storage</font></em></p>
<h1 id="Amazon-S3-Components"><a href="#Amazon-S3-Components" class="headerlink" title="Amazon S3 - Components"></a>Amazon S3 - Components</h1><p>Amazon S3 allows people to store objects (files) in buckets (directories).</p>
<h2 id="Buckets"><a href="#Buckets" class="headerlink" title="Buckets"></a>Buckets</h2><p><em><font color=red>S3 looks like a global service but buckets are created in a region</font></em></p>
<ul>
<li>Buckets must have a globally unique name (across all regions all accounts)</li>
<li>Buckets are defined at the region level</li>
<li>Name Convention<ul>
<li>No uppercase, No underscore</li>
<li>3-63 characters long</li>
<li>Not an IP</li>
<li>Must start with lowercase letter or number</li>
<li>Must NOT start with the prefix <code>xn--</code></li>
<li>Must NOT end with the suffix <code>-s3alias</code></li>
</ul>
</li>
</ul>
<h2 id="Objects"><a href="#Objects" class="headerlink" title="Objects"></a>Objects</h2><p><em><font color=red>Objects (files) have a Key. Key with very long names that contain slashes (“&#x2F;“).</font></em><br><em><font color=red>There is no concept of “directories” within buckets</font></em></p>
<ul>
<li>The key is the FULL path:<ul>
<li>s3:&#x2F;&#x2F;my-bucket&#x2F;my_folder&#x2F;another_folder&#x2F;my_file.txt</li>
</ul>
</li>
<li>The key is composed of <font color=red>prefix</font> + <font color=green>object name</font><ul>
<li>s3:&#x2F;&#x2F;my-bucket&#x2F;<font color=red>my_folder&#x2F;another_folder&#x2F;</font><font color=green>my_file.txt</font></li>
</ul>
</li>
<li>Object values are the content of the body:<ul>
<li>Max. Object Size is 5 TB (5000 GB)</li>
<li>If uploading more than 5 GB, must use “multi-part upload”.</li>
</ul>
</li>
<li>Metadata<ul>
<li>List of text key&#x2F;value pairs</li>
<li>System or user metadata</li>
</ul>
</li>
<li>Tags<ul>
<li>Unicode key&#x2F;value pair</li>
<li>Up to 10</li>
<li>Useful for security&#x2F;lifecycle</li>
</ul>
</li>
<li>Version ID<ul>
<li>If versioning is enabled</li>
</ul>
</li>
</ul>
<h1 id="Use-Cases"><a href="#Use-Cases" class="headerlink" title="Use Cases"></a>Use Cases</h1><ul>
<li>Backup &amp; Storage</li>
<li>Disaster Recovery</li>
<li>Archive</li>
<li>Hybrid Cloud Storage</li>
<li>Application&#x2F;Media Hosting</li>
<li>Data Lakes &amp; Big Data Analytics</li>
<li>Software Delivery</li>
<li>Static Website</li>
</ul>
<h2 id="Business-Use-Cases"><a href="#Business-Use-Cases" class="headerlink" title="Business Use Cases"></a>Business Use Cases</h2><ul>
<li>Nasdaq stores 7 years of data into Glacier</li>
<li>Sysco runs analytics on its data and gain business insights</li>
</ul>
<h1 id="Limitations"><a href="#Limitations" class="headerlink" title="Limitations"></a>Limitations</h1>]]></content>
      <tags>
        <tag>S3</tag>
        <tag>★☆★</tag>
      </tags>
  </entry>
  <entry>
    <title>Plotly - Advanced</title>
    <url>/2023/08/05/TempNotes/Plotly-Advanced/</url>
    <content><![CDATA[<h1 id="For-Example-Line-Plots"><a href="#For-Example-Line-Plots" class="headerlink" title="For Example: Line Plots"></a>For Example: Line Plots</h1><p>📘 Download <a href="https://www.kaggle.com/datasets/garrickhague/world-earthquake-data-from-1906-2022">World Earthquake Data From 1906-2022</a></p>
<hr>
<h2 id="Line-Plots-with-plotly-express"><a href="#Line-Plots-with-plotly-express" class="headerlink" title="Line Plots with plotly.express"></a>Line Plots with <code>plotly.express</code></h2><p><em><font color=royalblue>The plotly.express module (usually imported as px) contains functions that can create entire figures at once.<br>Plotly Express is a built-in part of the plotly library, and is the recommended starting point for creating most common figures.</font></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-processing</span></span><br><span class="line">df[<span class="string">&#x27;Year&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;time&#x27;</span>]).dt.year</span><br><span class="line">df[<span class="string">&quot;Country&quot;</span>] = df[<span class="string">&quot;place&quot;</span>].<span class="built_in">str</span>.split(pat=<span class="string">&#x27;,&#x27;</span>, expand=<span class="literal">False</span>).<span class="built_in">str</span>.get(-<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;Max_mag&quot;</span>] = df.groupby([<span class="string">&#x27;Year&#x27;</span>])[<span class="string">&#x27;mag&#x27;</span>].transform(<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line">df = df.query(<span class="string">&quot;2012 &lt;= Year &lt;= 2022&quot;</span>)</span><br><span class="line">fig = px.line(df, x=<span class="string">&quot;Year&quot;</span>, y=<span class="string">&quot;Max_mag&quot;</span>, title=<span class="string">&#x27;Max magnitude from 2000 to 2022&#x27;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<ul>
<li>Explanation<ul>
<li><p>Pandas <code>groupby</code> splits all the records from your data set into different categories or groups and offers you flexibility to analyze the data by these groups.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Group by &#x27;Year&#x27;, and get the maximum of &#x27;mag&#x27; column</span></span><br><span class="line">df.groupby([<span class="string">&#x27;Year&#x27;</span>])[<span class="string">&#x27;mag&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Group by &#x27;Year&#x27;, get the maximum of &#x27;mag&#x27; column, and fit the length of dataframe  </span></span><br><span class="line">df.groupby([<span class="string">&#x27;Year&#x27;</span>])[<span class="string">&#x27;mag&#x27;</span>].transform(<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Query &#x27;2022 &gt;= Year &gt;= 2021&#x27; and get the value of &#x27;Max_mag&#x27; column</span></span><br><span class="line">df.query(<span class="string">&quot;2022 &gt;= Year &gt;= 2021&quot;</span>)[<span class="string">&quot;Max_mag&quot;</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="Line-Plots-with-Column-Encoding-Color"><a href="#Line-Plots-with-Column-Encoding-Color" class="headerlink" title="Line Plots with Column Encoding Color"></a>Line Plots with Column Encoding Color</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-processing</span></span><br><span class="line">df[<span class="string">&#x27;Year&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;time&#x27;</span>]).dt.year</span><br><span class="line">df[<span class="string">&quot;Country&quot;</span>] = df[<span class="string">&quot;place&quot;</span>].<span class="built_in">str</span>.split(pat=<span class="string">&#x27;,&#x27;</span>, expand=<span class="literal">False</span>).<span class="built_in">str</span>.get(-<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;Max_mag&quot;</span>] = df.groupby([<span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;magType&#x27;</span>])[<span class="string">&#x27;mag&#x27;</span>].transform(<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line">df = df.query(<span class="string">&quot;2012 &lt;= Year &lt;= 2022&quot;</span>)</span><br><span class="line">fig = px.line(df, x=<span class="string">&quot;Year&quot;</span>, y=<span class="string">&quot;Max_mag&quot;</span>, </span><br><span class="line">  title=<span class="string">&#x27;Max magnitude from 2012 to 2022&#x27;</span>, color=<span class="string">&#x27;magType&#x27;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<ul>
<li>Explanation<ul>
<li><p>Pandas <code>groupby</code> splits all the records from your data set into different categories or groups and offers you flexibility to analyze the data by these groups.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Group by &#x27;Year&#x27; and &#x27;magType&#x27;, and get the maximum of &#x27;mag&#x27; column</span></span><br><span class="line">df.groupby([<span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;magType&#x27;</span>])[<span class="string">&#x27;mag&#x27;</span>].<span class="built_in">max</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Group by &#x27;Year&#x27; and &#x27;magType&#x27;, get the maximum of &#x27;mag&#x27; column, and fit the length of dataframe  </span></span><br><span class="line">df.groupby([<span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;magType&#x27;</span>])[<span class="string">&#x27;mag&#x27;</span>].transform(<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Query &#x27;2022 &gt;= Year &gt;= 2021&#x27; and get the value of &#x27;Max_mag&#x27; column</span></span><br><span class="line">df.query(<span class="string">&quot;2022 &gt;= Year &gt;= 2021&quot;</span>)[<span class="string">&quot;Max_mag&quot;</span>]</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<hr>
<h2 id="Basic-Settings"><a href="#Basic-Settings" class="headerlink" title="Basic Settings"></a>Basic Settings</h2><h3 id="Line-charts-with-Markers"><a href="#Line-charts-with-Markers" class="headerlink" title="Line charts with Markers"></a>Line charts with Markers</h3><ul>
<li><p>Set Title</p>
<ul>
<li><code>title = &#39;Max magnitude and Min depth from 2012 to 2022&#39;</code></li>
</ul>
</li>
<li><p>Add one more field on text label</p>
<ul>
<li><p><code>text = &quot;Min_depth&quot;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-processing</span></span><br><span class="line">df[<span class="string">&#x27;Year&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;time&#x27;</span>]).dt.year</span><br><span class="line">df[<span class="string">&quot;Country&quot;</span>] = df[<span class="string">&quot;place&quot;</span>].<span class="built_in">str</span>.split(pat=<span class="string">&#x27;,&#x27;</span>, expand=<span class="literal">False</span>).<span class="built_in">str</span>.get(-<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;Max_mag&quot;</span>] = df.groupby([<span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;magType&#x27;</span>])[<span class="string">&#x27;mag&#x27;</span>].transform(<span class="built_in">max</span>)</span><br><span class="line">df[<span class="string">&quot;Min_depth&quot;</span>] = df.groupby([<span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;magType&#x27;</span>])[<span class="string">&#x27;depth&#x27;</span>].transform(<span class="built_in">min</span>)</span><br><span class="line"></span><br><span class="line">query_df = df.query(<span class="string">&quot;2022 &gt;= Year &gt;= 2012 &amp; magType in [&#x27;mw&#x27;, &#x27;ml&#x27;, &#x27;ms&#x27;, &#x27;mb&#x27;]&quot;</span>)</span><br><span class="line">fig = px.line(query_df, x=<span class="string">&quot;Year&quot;</span>, y=<span class="string">&quot;Max_mag&quot;</span>, </span><br><span class="line">  title=<span class="string">&#x27;Max magnitude and Min depth from 2012 to 2022&#x27;</span>, </span><br><span class="line">  color=<span class="string">&#x27;magType&#x27;</span>, text=<span class="string">&quot;Min_depth&quot;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Mark data points</p>
<ul>
<li><p>Method 1: <code>markers = True</code></p>
</li>
<li><p>Method 2: <code>symbol = &quot;magType&quot;</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-processing</span></span><br><span class="line">df[<span class="string">&#x27;Year&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;time&#x27;</span>]).dt.year</span><br><span class="line">df[<span class="string">&quot;Country&quot;</span>] = df[<span class="string">&quot;place&quot;</span>].<span class="built_in">str</span>.split(pat=<span class="string">&#x27;,&#x27;</span>, expand=<span class="literal">False</span>).<span class="built_in">str</span>.get(-<span class="number">1</span>)</span><br><span class="line">df[<span class="string">&quot;Max_mag&quot;</span>] = df.groupby([<span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;magType&#x27;</span>])[<span class="string">&#x27;mag&#x27;</span>].transform(<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line">query_df = df.query(<span class="string">&quot;2022 &gt;= Year &gt;= 2012&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 1: markers</span></span><br><span class="line">fig = px.line(query_df, x=<span class="string">&quot;Year&quot;</span>, y=<span class="string">&quot;Max_mag&quot;</span>, </span><br><span class="line">  title=<span class="string">&#x27;Max magnitude from 2012 to 2022&#x27;</span>, </span><br><span class="line">  color=<span class="string">&#x27;magType&#x27;</span>, markers=<span class="literal">True</span>)</span><br><span class="line">fig.show()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2: symbol</span></span><br><span class="line">fig = px.line(query_df, x=<span class="string">&quot;Year&quot;</span>, y=<span class="string">&quot;Max_mag&quot;</span>, </span><br><span class="line">  title=<span class="string">&#x27;Max magnitude from 2012 to 2022&#x27;</span>, </span><br><span class="line">  color=<span class="string">&#x27;magType&#x27;</span>, symbol=<span class="string">&quot;magType&quot;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<h3 id="Save-a-Plot"><a href="#Save-a-Plot" class="headerlink" title="Save a Plot"></a>Save a Plot</h3><figure class="highlight basic"><table><tr><td class="code"><pre><span class="line"># Install Package</span><br><span class="line">$ pip install -U kaleido</span><br></pre></td></tr></table></figure>

<ul>
<li><p>Save a Figure in xxx Format: PNG, JPEG, SVG, PDF</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># PNG</span></span><br><span class="line">fig.write_image(<span class="string">&quot;fig1.png&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># JPEG</span></span><br><span class="line">fig.write_image(<span class="string">&quot;fig1.jpeg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># SVG</span></span><br><span class="line">fig.write_image(<span class="string">&quot;fig1.svg&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PDF</span></span><br><span class="line">fig.write_image(<span class="string">&quot;fig1.pdf&quot;</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Change Image dimension and Scale</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig.write_image(<span class="string">&#x27;fig2_scale2.jpeg&#x27;</span>, width=<span class="number">600</span>, height=<span class="number">350</span>, scale=<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>Interactive HTML export in Plotly Python</p>
  <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">fig.write_html(<span class="string">&quot;fig1.html&quot;</span>, auto_open=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="Advanced-Interactive-Custom-Controls"><a href="#Advanced-Interactive-Custom-Controls" class="headerlink" title="Advanced: Interactive Custom Controls"></a>Advanced: Interactive Custom Controls</h2><h3 id="Basic-Range-Slider-and-Range-Selectors"><a href="#Basic-Range-Slider-and-Range-Selectors" class="headerlink" title="Basic Range Slider and Range Selectors"></a>Basic Range Slider and Range Selectors</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.graph_objects <span class="keyword">as</span> go</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line"><span class="comment"># Load data</span></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Pre-processing</span></span><br><span class="line">df[<span class="string">&#x27;Year&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;time&#x27;</span>]).dt.year</span><br><span class="line">df[<span class="string">&quot;Max_mag&quot;</span>] = df.groupby([<span class="string">&#x27;Year&#x27;</span>, <span class="string">&#x27;magType&#x27;</span>])[<span class="string">&#x27;mag&#x27;</span>].transform(<span class="built_in">max</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Query</span></span><br><span class="line">query_df = df.query(<span class="string">&quot;magType == &#x27;mww&#x27;&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create figure</span></span><br><span class="line">fig = go.Figure()</span><br><span class="line"></span><br><span class="line">fig.add_trace(</span><br><span class="line">    go.Scatter(x=<span class="built_in">list</span>(query_df.time), y=<span class="built_in">list</span>(query_df.Max_mag)))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set title</span></span><br><span class="line">fig.update_layout(</span><br><span class="line">    title_text=<span class="string">&quot;Time series with range slider and selectors&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add range slider</span></span><br><span class="line">fig.update_layout(</span><br><span class="line">    xaxis=<span class="built_in">dict</span>(</span><br><span class="line">        rangeselector=<span class="built_in">dict</span>(</span><br><span class="line">            buttons=<span class="built_in">list</span>([</span><br><span class="line">                <span class="built_in">dict</span>(count=<span class="number">1</span>, label=<span class="string">&quot;1m&quot;</span>, step=<span class="string">&quot;month&quot;</span>, stepmode=<span class="string">&quot;backward&quot;</span>),</span><br><span class="line">                <span class="built_in">dict</span>(count=<span class="number">6</span>, label=<span class="string">&quot;6m&quot;</span>, step=<span class="string">&quot;month&quot;</span>, stepmode=<span class="string">&quot;backward&quot;</span>),</span><br><span class="line">                <span class="built_in">dict</span>(count=<span class="number">1</span>, label=<span class="string">&quot;YTD&quot;</span>, step=<span class="string">&quot;year&quot;</span>, stepmode=<span class="string">&quot;todate&quot;</span>),</span><br><span class="line">                <span class="built_in">dict</span>(count=<span class="number">1</span>, label=<span class="string">&quot;1y&quot;</span>, step=<span class="string">&quot;year&quot;</span>, stepmode=<span class="string">&quot;backward&quot;</span>),</span><br><span class="line">                <span class="built_in">dict</span>(step=<span class="string">&quot;all&quot;</span>)</span><br><span class="line">            ])</span><br><span class="line">        ),</span><br><span class="line">        rangeslider=<span class="built_in">dict</span>( visible=<span class="literal">True</span> ),</span><br><span class="line">        <span class="built_in">type</span>=<span class="string">&quot;date&quot;</span></span><br><span class="line">    )</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://www.usgs.gov/programs/earthquake-hazards/magnitude-types">USGS - Magnitude Types</a></li>
<li><a href="https://academic-accelerator.com/encyclopedia/zh/moment-magnitude-scale">矩量級 Moment Magnitude Scale</a></li>
<li><a href="https://www.facebook.com/momlovestaiwan/photos/a.1076309132504673/1076350115833908/?type=3&locale=zh_TW">Magnitude Type: Mw vs. ML vs. MS vs. mb</a></li>
<li><a href="https://plotly.com/python/">Plotly Open Source Graphing Library for Python</a></li>
</ul>
]]></content>
      <tags>
        <tag>Data Visualization</tag>
        <tag>Python</tag>
        <tag>Plotly</tag>
      </tags>
  </entry>
  <entry>
    <title>Plotly - Basics</title>
    <url>/2023/08/03/TempNotes/Plotly-Basics/</url>
    <content><![CDATA[<blockquote>
<h3><i><font color=saddlebrown>If you work with massive datasets, <br>you can use a library like Plotly, designed to handle massive datasets well.</font></i></h3>
</blockquote>
<hr>
<h1 id="Before-Doing-Data-Visualization"><a href="#Before-Doing-Data-Visualization" class="headerlink" title="Before Doing Data Visualization"></a>Before Doing Data Visualization</h1><h2 id="Find-Datasets"><a href="#Find-Datasets" class="headerlink" title="Find Datasets"></a>Find Datasets</h2><ul>
<li><a href="https://www.kaggle.com/datasets">Kaggle Datasets</a></li>
<li><a href="https://datasetsearch.research.google.com/">Google Dataset Search</a></li>
<li><a href="https://data.gov.tw/">Taiwan Government’s Open Data</a></li>
<li><a href="https://data.gov/">The U.S. Government’s Open Data</a></li>
<li>…</li>
</ul>
<h2 id="Prepared-Environment"><a href="#Prepared-Environment" class="headerlink" title="Prepared Environment"></a>Prepared Environment</h2><ul>
<li>Install packages<ul>
<li>Plotly</li>
<li>Pandas</li>
<li><a href="https://jupyter.org/install">JupyterLab</a></li>
</ul>
</li>
</ul>
<figure class="highlight basic"><table><tr><td class="code"><pre><span class="line">$ pip install plotly==<span class="number">5.15</span>.<span class="number">0</span></span><br><span class="line">$ pip install pandas</span><br><span class="line">$ pip install jupyterlab</span><br><span class="line">$ jupyter lab</span><br></pre></td></tr></table></figure>

<h2 id="Load-Dataset"><a href="#Load-Dataset" class="headerlink" title="Load Dataset"></a>Load Dataset</h2><p>📘 Download <a href="https://www.kaggle.com/datasets/garrickhague/world-earthquake-data-from-1906-2022">World Earthquake Data From 1906-2022</a></p>
<ul>
<li><code>head()</code><ul>
<li>Shows the first n (the default is 5) rows</li>
</ul>
</li>
<li><code>tail()</code><ul>
<li>The “opposite” method of head() is tail()</li>
<li>Shows the last n (5 by default) rows of the dataframe object</li>
</ul>
</li>
<li><code>info()</code> <ul>
<li>Prints out a concise summary of the dataframe, including information about the index, data types, columns, non-null values, and memory usage</li>
</ul>
</li>
<li><code>describe()</code><ul>
<li>Generates descriptive statistics, including those that summarize the central tendency, dispersion, and shape of the dataset’s distribution</li>
</ul>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Shows the first 5 rows</span></span><br><span class="line"><span class="built_in">print</span>(df.head())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Shows the last 5 rows</span></span><br><span class="line"><span class="built_in">print</span>(df.tail())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Concise summary of the dataframe</span></span><br><span class="line"><span class="built_in">print</span>(df.info())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Descriptive statistics</span></span><br><span class="line"><span class="built_in">print</span>(df.describe())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save as `Year` field</span></span><br><span class="line">df[<span class="string">&#x27;Year&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;time&#x27;</span>]).dt.year</span><br><span class="line"></span><br><span class="line"><span class="comment"># Save as `Country` field</span></span><br><span class="line">df[<span class="string">&quot;Country&quot;</span>] = df[<span class="string">&quot;place&quot;</span>].<span class="built_in">str</span>.split(pat=<span class="string">&#x27;,&#x27;</span>, expand=<span class="literal">False</span>).<span class="built_in">str</span>.get(-<span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><em><font color=royalblue>After collection, most data requires some degree of cleaning or reformatting before it can be analyzed or used to create visualizations.</font></em></p>
<hr>
<h1 id="Getting-Started-Plotly"><a href="#Getting-Started-Plotly" class="headerlink" title="Getting Started - Plotly"></a>Getting Started - <a href="https://plotly.com/python/">Plotly</a></h1><h2 id="Line-Charts"><a href="#Line-Charts" class="headerlink" title="Line Charts"></a>Line Charts</h2><p>Line charts are used to convey changes over time.</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = px.data.gapminder().query(<span class="string">&quot;country==&#x27;Canada&#x27;&quot;</span>)</span><br><span class="line">fig = px.line(df, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;lifeExp&quot;</span>, title=<span class="string">&#x27;Life expectancy in Canada&#x27;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = px.data.gapminder().query(<span class="string">&quot;continent==&#x27;Oceania&#x27;&quot;</span>)</span><br><span class="line">fig = px.line(df, x=<span class="string">&quot;year&quot;</span>, y=<span class="string">&quot;lifeExp&quot;</span>, color=<span class="string">&#x27;country&#x27;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<h2 id="Histogram"><a href="#Histogram" class="headerlink" title="Histogram"></a>Histogram</h2><p>Use a histogram to visualize the frequency distribution of a single event over a certain time period.<br><em><font color=royalblue>A histogram is the graphical representation of quantitative data.</font></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = px.data.tips()</span><br><span class="line">fig = px.histogram(df, x=<span class="string">&quot;total_bill&quot;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<h2 id="Bar-Charts"><a href="#Bar-Charts" class="headerlink" title="Bar Charts"></a>Bar Charts</h2><p><em><font color=royalblue>The bar chart is the graphical representation of categorical data.</font></em></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">long_df = px.data.medals_long()</span><br><span class="line">fig = px.bar(long_df, x=<span class="string">&quot;nation&quot;</span>, y=<span class="string">&quot;count&quot;</span>, color=<span class="string">&quot;medal&quot;</span>, title=<span class="string">&quot;Long-Form Input&quot;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<h2 id="Scatter-Plots"><a href="#Scatter-Plots" class="headerlink" title="Scatter Plots"></a>Scatter Plots</h2><p>If you wanted to <strong>highlight the relationship or correlations between two variables</strong> (e.g. marketing spend and revenue, or hours of weekly exercise vs. cardiovascular fitness), you could use a scatter plot to see, at a glance, if one increases as the other decreases (or vice versa).</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line">df[<span class="string">&#x27;Year&#x27;</span>] = pd.to_datetime(df[<span class="string">&#x27;time&#x27;</span>]).dt.year</span><br><span class="line">fig = px.scatter(df, x=<span class="string">&quot;Year&quot;</span>, y=<span class="string">&quot;mag&quot;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<h2 id="Pie-chart"><a href="#Pie-chart" class="headerlink" title="Pie chart"></a>Pie chart</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = px.data.tips()</span><br><span class="line">fig = px.pie(df, values=<span class="string">&#x27;tip&#x27;</span>, names=<span class="string">&#x27;day&#x27;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<h2 id="Maps"><a href="#Maps" class="headerlink" title="Maps"></a>Maps</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Draw a map after doing `mag &gt;= 7` query</span></span><br><span class="line">fig = px.density_mapbox(df.query(<span class="string">&quot;mag &gt;= 7&quot;</span>), lat=<span class="string">&#x27;latitude&#x27;</span>, lon=<span class="string">&#x27;longitude&#x27;</span>, z=<span class="string">&#x27;mag&#x27;</span>, radius=<span class="number">10</span>,</span><br><span class="line">                        center=<span class="built_in">dict</span>(lat=<span class="number">0</span>, lon=<span class="number">180</span>), zoom=<span class="number">0</span>, mapbox_style=<span class="string">&quot;stamen-terrain&quot;</span>)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> plotly.express <span class="keyword">as</span> px</span><br><span class="line"></span><br><span class="line">df = pd.read_csv(<span class="string">&#x27;data.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Do pre-processing on `place` field </span></span><br><span class="line">df[<span class="string">&quot;Country&quot;</span>] = df[<span class="string">&quot;place&quot;</span>].<span class="built_in">str</span>.split(pat=<span class="string">&#x27;,&#x27;</span>, expand=<span class="literal">False</span>).<span class="built_in">str</span>.get(-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">fig = px.scatter_mapbox(df.query(<span class="string">&quot;mag &gt;= 7&quot;</span>), lat=<span class="string">&quot;latitude&quot;</span>, lon=<span class="string">&quot;longitude&quot;</span>, </span><br><span class="line">                        hover_name=<span class="string">&quot;Country&quot;</span>, hover_data=[<span class="string">&quot;mag&quot;</span>, <span class="string">&quot;depth&quot;</span>],</span><br><span class="line">                        color_discrete_sequence=[<span class="string">&quot;red&quot;</span>], zoom=<span class="number">3</span>, height=<span class="number">300</span>)</span><br><span class="line">fig.update_layout(mapbox_style=<span class="string">&quot;open-street-map&quot;</span>)</span><br><span class="line">fig.update_layout(margin=&#123;<span class="string">&quot;r&quot;</span>:<span class="number">0</span>,<span class="string">&quot;t&quot;</span>:<span class="number">0</span>,<span class="string">&quot;l&quot;</span>:<span class="number">0</span>,<span class="string">&quot;b&quot;</span>:<span class="number">0</span>&#125;)</span><br><span class="line">fig.show()</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://plotly.com/python/plotly-fundamentals/">Plotly Python Open Source Graphing Library Fundamentals</a></li>
<li><a href="https://www.datacamp.com/tutorial/python-plotly-express-tutorial">Python Plotly Express Tutorial: Unlock Beautiful Visualizations</a></li>
</ul>
]]></content>
      <tags>
        <tag>Data Visualization</tag>
        <tag>Python</tag>
        <tag>Plotly</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Security | Authorization</title>
    <url>/2025/07/09/K8s-Advanced/K8s-Security-Authorization/</url>
    <content><![CDATA[<h1 id="Why-Authorization"><a href="#Why-Authorization" class="headerlink" title="Why Authorization?"></a>Why Authorization?</h1><p>在 K8s 中，不同類型的實體（例如 Admins、Developers、Bots）執行的操作權限應有所區隔，以維護叢集的安全性與資源隔離。因此，我們需要使用 <code>授權機制（Authorization Mechanisms）</code> 來精細控管誰可以做什麼。</p>
<h2 id="Authorization-Mechanisms"><a href="#Authorization-Mechanisms" class="headerlink" title="Authorization Mechanisms"></a>Authorization Mechanisms</h2><h3 id="Node-Authorizer"><a href="#Node-Authorizer" class="headerlink" title="Node Authorizer"></a>Node Authorizer</h3><p>Node Authorizer 是一種專門授權給 Kubernetes <strong>kubelet（節點代理程式）</strong> 的機制，允許它只能存取與其自身相關的資源。</p>
<blockquote>
<p>這是一種特殊的授權方式，僅適用於節點自身，與一般使用者授權不同。</p>
</blockquote>
<p>📌 補充：kubelet 還能讀取其所在節點的 ConfigMap 和 Secrets（如果 pod 有 mount）。</p>
<ul>
<li>認證方式：<ul>
<li><code>Kube API Server</code> 通過 <strong>user identity</strong> 與 <strong>TLS certificate</strong> 判斷請求來源是否為節點。</li>
</ul>
</li>
<li>適用對象：<ul>
<li><code>kubelet</code>（節點）</li>
</ul>
</li>
<li>節點允許操作的資源範圍如下：<ul>
<li>Read: Services、Endpoints、Nodes（僅限自身資訊）、Pods（僅限指派給該 Node 的 Pods）</li>
<li>Write: Node status、Pod status、events</li>
</ul>
</li>
</ul>
<h3 id="ABAC"><a href="#ABAC" class="headerlink" title="ABAC"></a>ABAC</h3><p>ABAC 是早期 Kubernetes 所支援的授權機制之一，透過靜態 JSON policy 檔案控制每個使用者對資源的操作權限。</p>
<ul>
<li>缺點：<ul>
<li>無法細緻管理</li>
<li>權限定義採靜態設定，不易維護</li>
<li>無法動態調整：無法根據動態條件做出授權決策</li>
<li>無法做到角色抽象（Role-based grouping）</li>
<li>設定變更需重新啟動 API Server</li>
</ul>
</li>
<li>實務現況：<ul>
<li><mark>已被 RBAC 取代，Kubernetes 1.8+ 預設啟用 RBAC。</mark></li>
</ul>
</li>
</ul>
<h4 id="ABAC-實例說明"><a href="#ABAC-實例說明" class="headerlink" title="ABAC 實例說明"></a>ABAC 實例說明</h4><table>
<thead>
<tr>
<th>使用者 &#x2F; 群組</th>
<th>權限內容</th>
</tr>
</thead>
<tbody><tr>
<td><code>dev-user</code></td>
<td>可檢視、建立、刪除 Pods</td>
</tr>
<tr>
<td><code>dev-user-2</code></td>
<td>可檢視、建立、刪除 Pods</td>
</tr>
<tr>
<td><code>dev-users</code></td>
<td>（群組）可檢視、建立、刪除 Pods</td>
</tr>
<tr>
<td><code>security-1</code></td>
<td>可檢視與核准 CSR（憑證簽署請求）</td>
</tr>
</tbody></table>
<p>完整 ABAC Policy（單一使用者範例）(e.g. dev-user)</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;abac.authorization.kubernetes.io/v1beta1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Policy&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;spec&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dev-user&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pods&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;apiGroup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;verb&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>多筆簡化 ABAC Policy（陣列格式）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Policy&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;spec&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dev-user&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pods&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;apiGroup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Policy&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;spec&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dev-user-2&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pods&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;apiGroup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Policy&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;spec&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;group&quot;</span><span class="punctuation">:</span> <span class="string">&quot;dev-users&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pods&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;apiGroup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="punctuation">&#123;</span><span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Policy&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;spec&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;user&quot;</span><span class="punctuation">:</span> <span class="string">&quot;security-1&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;namespace&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;resource&quot;</span><span class="punctuation">:</span> <span class="string">&quot;csr&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;apiGroup&quot;</span><span class="punctuation">:</span> <span class="string">&quot;*&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>

<h3 id="RBAC（Role-Based-Access-Control）"><a href="#RBAC（Role-Based-Access-Control）" class="headerlink" title="RBAC（Role-Based Access Control）"></a>RBAC（Role-Based Access Control）</h3><p>RBAC 是目前 Kubernetes 預設且推薦使用的授權機制，透過角色與綁定來控制使用者與資源間的權限關係。</p>
<ul>
<li>設計理念<ul>
<li>Role&#x2F;ClusterRole：定義一組權限（verbs + resources）</li>
<li>RoleBinding&#x2F;ClusterRoleBinding：將角色賦予給特定的使用者、群組或 ServiceAccount</li>
</ul>
</li>
</ul>
<h4 id="權限範例角色設計"><a href="#權限範例角色設計" class="headerlink" title="權限範例角色設計"></a>權限範例角色設計</h4><ul>
<li>Developer 角色<ul>
<li>✓ Can view PODs</li>
<li>✓ Can create PODs</li>
<li>✓ Can Delete PODs</li>
<li>✓ Can Create ConfigMaps</li>
<li>對應使用者／群組：dev-user, dev-user-2, dev-users</li>
</ul>
</li>
<li>Security 角色<ul>
<li>✓ Can view CSR（CertificateSigningRequest, 憑證簽署流程資源）</li>
<li>✓ Can approve CSR</li>
<li>對應使用者： security-1</li>
</ul>
</li>
</ul>
<h3 id="Webhook-OPA"><a href="#Webhook-OPA" class="headerlink" title="Webhook (OPA)"></a>Webhook (OPA)</h3><p>Webhook 模式允許 K8s 把授權判斷交由外部系統決策，最常見的實作是 <a href="https://www.openpolicyagent.org/">OPA - Open Policy Agent</a>。</p>
<blockquote>
<p><code>Gatekeeper</code> 是實作 OPA 的常用工具。</p>
</blockquote>
<h4 id="授權流程"><a href="#授權流程" class="headerlink" title="授權流程"></a>授權流程</h4><ol>
<li>使用者（例如 <code>dev-user</code>）發送操作請求，例如建立 Pod。</li>
<li>API Server 傳送請求至 OPA webhook：API Server 根據 –authorization-mode&#x3D;Webhook 設定，呼叫外部 Webhook 伺服器。</li>
<li>Webhook（如 OPA）根據 Rego Policy 檢查是否允許（allow）該操作。</li>
<li>Webhook 回傳 JSON 結果：<ul>
<li>HTTP 200 OK</li>
<li><code>allowed: true</code>（或 false） <figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;apiVersion&quot;</span><span class="punctuation">:</span> <span class="string">&quot;authorization.k8s.io/v1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;kind&quot;</span><span class="punctuation">:</span> <span class="string">&quot;SubjectAccessReview&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;status&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;allowed&quot;</span><span class="punctuation">:</span> <span class="literal"><span class="keyword">true</span></span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<h2 id="Authorization-Mode（授權模式）"><a href="#Authorization-Mode（授權模式）" class="headerlink" title="Authorization Mode（授權模式）"></a>Authorization Mode（授權模式）</h2><p>Kubernetes 支援多種授權模式，可同時啟用、並依照順序判斷：</p>
<table>
<thead>
<tr>
<th>模式類型</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Node</code></td>
<td>僅授權 kubelet 對自己相關資源進行操作</td>
</tr>
<tr>
<td><code>ABAC</code></td>
<td>靜態 JSON-based 授權（已不建議）</td>
</tr>
<tr>
<td><code>RBAC</code></td>
<td>推薦使用的角色型授權，支援群組、角色綁定等</td>
</tr>
<tr>
<td><code>Webhook</code></td>
<td>呼叫外部系統（如 OPA）進行決策</td>
</tr>
<tr>
<td><code>AlwaysAllow</code></td>
<td>所有請求都允許（不安全，僅用於測試）</td>
</tr>
<tr>
<td><code>AlwaysDeny</code></td>
<td>所有請求都拒絕（不實用）</td>
</tr>
</tbody></table>


<h3 id="API-Server-啟動參數範例"><a href="#API-Server-啟動參數範例" class="headerlink" title="API Server 啟動參數範例"></a>API Server 啟動參數範例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/local/bin/kube-apiserver \</span><br><span class="line">  --advertise-address=<span class="variable">$&#123;INTERNAL_IP&#125;</span> \</span><br><span class="line">  --allow-privileged=<span class="literal">true</span> \</span><br><span class="line">  --apiserver-count=3 \</span><br><span class="line">  --authorization-mode=Node,RBAC,Webhook \</span><br><span class="line">  <span class="comment"># 其他參數略 ...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可同時啟用多種授權機制，<strong>系統會依序進行授權檢查</strong>。</p>
</blockquote>


<div class="note info"><p><code>--authorization-mode=Node,RBAC,Webhook</code> 的授權順序如下：<br><code>**Node → RBAC → Webhook**</code><br>一旦任一授權模式允許該請求，API Server 即允許此操作。</p>
<p>⚠ ABAC 與 RBAC 無法同時混用，需在啟動參數中選擇要用哪一個，且 ABAC 修改 policy 後需重啟 API Server。</p>
</div>

<hr>
<h1 id="RBAC"><a href="#RBAC" class="headerlink" title="RBAC"></a>RBAC</h1><h2 id="API-Group-與-RBAC-對應關係"><a href="#API-Group-與-RBAC-對應關係" class="headerlink" title="API Group 與 RBAC 對應關係"></a>API Group 與 RBAC 對應關係</h2><table>
<thead>
<tr>
<th>資源</th>
<th>API Group</th>
<th>RBAC 設定</th>
</tr>
</thead>
<tbody><tr>
<td>pods</td>
<td><code>&quot;&quot;</code> (core group)</td>
<td><code>apiGroups: [&quot;&quot;]</code></td>
</tr>
<tr>
<td>deployments</td>
<td><code>apps</code> (apps group)</td>
<td><code>apiGroups: [&quot;apps&quot;]</code></td>
</tr>
<tr>
<td>RBAC 相關資源（roles, rolebindings）</td>
<td><code>rbac.authorization.k8s.io</code></td>
<td><code>apiGroups: [&quot;rbac.authorization.k8s.io&quot;]</code></td>
</tr>
</tbody></table>
<h2 id="Role-定義範例"><a href="#Role-定義範例" class="headerlink" title="Role 定義範例"></a>Role 定義範例</h2><ul>
<li>Role 是 namespace 級別的權限設定。</li>
<li>developer role 允許對 pods 做常用操作，並可建立 configmaps。</li>
<li>可限制特定資源名稱（resourceNames）來細化權限。</li>
</ul>
<h2 id="RoleBinding-綁定使用者"><a href="#RoleBinding-綁定使用者" class="headerlink" title="RoleBinding 綁定使用者"></a>RoleBinding 綁定使用者</h2><ul>
<li>RoleBinding 將 Role 角色授權給特定 user 或 group。</li>
<li>可綁定 User、Group 兩種 kind，方便配合 AD&#x2F;LDAP 使用。</li>
</ul>
<div class="note info"><p><strong>補充：Role&#x2F;RoleBinding vs ClusterRole&#x2F;ClusterRoleBinding</strong></p>
<table>
<thead>
<tr>
<th>角色類型</th>
<th>使用範圍</th>
<th>適用場景</th>
</tr>
</thead>
<tbody><tr>
<td>Role&#x2F;RoleBinding</td>
<td>單一 namespace</td>
<td>需限制在某 namespace</td>
</tr>
<tr>
<td>ClusterRole&#x2F;ClusterRoleBinding</td>
<td>全 cluster 或跨 namespace</td>
<td>跨 namespace 或需存取 cluster-wide 資源如 nodes、secrets</td>
</tr>
</tbody></table>
<p>⚠ 補充：「若你需讓一個 ServiceAccount 存取不同 namespace 的資源，應使用 <code>ClusterRole</code> + <code>RoleBinding</code> 在各命名空間分別綁定」。</p>
<br>

<p><strong>補充：ClusterRoleBinding</strong></p>
<ul>
<li>將 ClusterRole 授權給特定使用者，作用範圍為整個 cluster 或跨 namespace。</li>
</ul>
<br>

<p><strong>實務場景應用建議</strong></p>
<table>
<thead>
<tr>
<th>用途</th>
<th>建議方式</th>
</tr>
</thead>
<tbody><tr>
<td>單 Namespace 權限控制</td>
<td>使用 <code>Role + RoleBinding</code></td>
</tr>
<tr>
<td>跨 Namespace 或叢集資源</td>
<td>使用 <code>ClusterRole + ClusterRoleBinding</code></td>
</tr>
<tr>
<td>外部政策控制</td>
<td>整合 OPA + Gatekeeper</td>
</tr>
<tr>
<td>動態用戶群管理</td>
<td>搭配 AD&#x2F;LDAP group</td>
</tr>
</tbody></table>
</div>

<h2 id="指令操作"><a href="#指令操作" class="headerlink" title="指令操作"></a>指令操作</h2><h3 id="Create-Role"><a href="#Create-Role" class="headerlink" title="Create Role"></a>Create Role</h3><img src="/2025/07/09/K8s-Advanced/K8s-Security-Authorization/RBAC_1.jpg" class="">

<h4 id="developer-role-yaml"><a href="#developer-role-yaml" class="headerlink" title="developer-role.yaml"></a>developer-role.yaml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">developer</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;list&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>]</span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;configmaps&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;create&quot;</span>]</span><br></pre></td></tr></table></figure>

<details class="note default"><summary><p><code>developer-role.yaml</code> 補充：Resource Names</p>
</summary>
<p>限制只能使用哪些 resourceNames (“blue”, “orange”)</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># developer-role.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">developer</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;pods&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;get&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>]</span><br><span class="line">  <span class="attr">resourceNames:</span> [<span class="string">&quot;blue&quot;</span>, <span class="string">&quot;orange&quot;</span>]</span><br></pre></td></tr></table></figure>
</details>

<h4 id="Kubectl-Command"><a href="#Kubectl-Command" class="headerlink" title="Kubectl Command"></a>Kubectl Command</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f developer-role.yaml</span><br></pre></td></tr></table></figure>

<h3 id="Binding-role-and-users"><a href="#Binding-role-and-users" class="headerlink" title="Binding role and users"></a>Binding role and users</h3><img src="/2025/07/09/K8s-Advanced/K8s-Security-Authorization/RBAC_2.jpg" class="">

<h4 id="developer-role-yaml-1"><a href="#developer-role-yaml-1" class="headerlink" title="developer-role.yaml"></a>developer-role.yaml</h4><p>同上</p>
<h4 id="devuser-developer-binding-yaml"><a href="#devuser-developer-binding-yaml" class="headerlink" title="devuser-developer-binding.yaml"></a>devuser-developer-binding.yaml</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">RoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">devuser-developer-binding</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">dev-ns</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-user</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">Role</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">developer</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<details class="note default"><summary><p>RBAC 的 subjects 支援 3 種 kind</p>
</summary>
<p>RBAC 的 subjects 支援 3 種 kind：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-user</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">Group</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dev-team</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">app-ns</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>📌 當你的 cluster 使用 AD&#x2F;LDAP 整合，group 綁定會非常常見。</p>
</blockquote>

</details>

<h4 id="Kubectl-Command-1"><a href="#Kubectl-Command-1" class="headerlink" title="Kubectl Command"></a>Kubectl Command</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f devuser-developer-binding.yaml</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h1><h2 id="View-RBAC"><a href="#View-RBAC" class="headerlink" title="View RBAC"></a>View RBAC</h2><p>查看角色與綁定</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get roles</span><br><span class="line"></span><br><span class="line">kubectl get rolebindings</span><br></pre></td></tr></table></figure>

<p>針對角色詳細資訊</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe role [role_name]</span><br><span class="line">kubectl describe role developer</span><br><span class="line"></span><br><span class="line">kubectl describe rolebinding [rolebinding_name]</span><br><span class="line">kubectl describe rolebinding devuser-developer-binding</span><br></pre></td></tr></table></figure>

<h2 id="Check-Access"><a href="#Check-Access" class="headerlink" title="Check Access"></a>Check Access</h2><p>權限檢查</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl auth can-i [verb] [resource] --as [user] --namespace [ns]</span><br><span class="line"></span><br><span class="line">kubectl auth can-i create deployments</span><br><span class="line">kubectl auth can-i create deployments --as dev-user</span><br><span class="line">kubectl auth can-i create pods        --as dev-user</span><br><span class="line">kubectl auth can-i create pods        --as dev-user --namespace <span class="built_in">test</span></span><br><span class="line">kubectl auth can-i create pods        --as system:serviceaccount:app-ns:backend</span><br><span class="line"></span><br><span class="line">kubectl auth can-i delete nodes</span><br><span class="line"></span><br><span class="line">kubectl auth can-i get secrets --as dev-user</span><br><span class="line"><span class="comment"># → no</span></span><br></pre></td></tr></table></figure>

<p>若是 ClusterRole，記得補上 <code>--all-namespaces</code> 或 <code>--namespace</code> 以驗證生效範圍。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl auth can-i get pods --as dev-user --namespace default</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><ul>
<li>Kubernetes 提供多種授權模式：<ul>
<li><strong>Node Authorizer</strong>：授權 kubelet 等 node 元件存取必要資源</li>
<li><strong>ABAC</strong>：透過靜態 JSON Policy 授權（已較少使用）</li>
<li><strong>RBAC</strong>：最常見，透過 Role&#x2F;ClusterRole 與 RoleBinding 控管權限</li>
<li><strong>Webhook</strong>：交由外部系統如 OPA 決策授權</li>
</ul>
</li>
<li><code>--authorization-mode</code> 可同時啟用多種授權機制（Node, RBAC, Webhook）</li>
<li>RBAC 基本結構：<ul>
<li><code>Role/ClusterRole</code> 定義權限</li>
<li><code>RoleBinding/ClusterRoleBinding</code> 指派權限給 User&#x2F;Group&#x2F;ServiceAccount</li>
</ul>
</li>
<li>開發常用工具：<ul>
<li><code>kubectl auth can-i</code></li>
<li><code>kubectl get roles</code>、<code>rolebindings</code></li>
<li><code>kubectl describe role</code> 快速 debug 權限</li>
</ul>
</li>
</ul>
<p>📌 下一步建議：<br>了解 <strong>ServiceAccount 與 RoleBinding 搭配 Pod 運行身份</strong>，進入實務應用場景。</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Authorization</tag>
        <tag>ABAC</tag>
        <tag>RBAC</tag>
        <tag>Webhook</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Security | Image Security &amp; SecurityContext</title>
    <url>/2025/07/10/K8s-Advanced/K8s-Security-Image-SecurityContext/</url>
    <content><![CDATA[<h1 id="✅-背景知識與觀念"><a href="#✅-背景知識與觀念" class="headerlink" title="✅ 背景知識與觀念"></a>✅ 背景知識與觀念</h1><h2 id="Image-Security-觀念"><a href="#Image-Security-觀念" class="headerlink" title="Image Security 觀念"></a>Image Security 觀念</h2><ul>
<li>避免使用 <code>latest</code> tag → <strong>不可預測、風險高</strong></li>
<li>指定明確版本號（如 <code>nginx:1.24.2</code>）</li>
<li>儘量選擇：<ul>
<li>可信來源（官方、企業內部 registry）</li>
<li>已簽署 &#x2F; 掃描過的映像檔（搭配 Notary、Cosign）</li>
</ul>
</li>
<li>配合 <code>imagePullPolicy</code> 控制 image 更新策略</li>
<li>可搭配 Admission Controller 實作政策限制<ul>
<li>如：Gatekeeper + OPA、ImagePolicyWebhook</li>
</ul>
</li>
</ul>
<h2 id="Linux-Container-安全模型核心概念"><a href="#Linux-Container-安全模型核心概念" class="headerlink" title="Linux Container 安全模型核心概念"></a>Linux Container 安全模型核心概念</h2><ul>
<li><strong>Namespaces</strong>：隔離資源（PID、網路、Mount 等）</li>
<li><strong>cgroups</strong>：限制資源（CPU、Memory）</li>
<li><strong>Capabilities</strong>：限制容器能使用哪些權限</li>
<li><strong>seccomp</strong>：限制能呼叫哪些 system calls</li>
</ul>
<blockquote>
<p>Kubernetes 為了安全性，<strong>不建議容器以 root 身份執行</strong>，應使用 non-root user。</p>
</blockquote>
<hr>
<h1 id="Image-Security"><a href="#Image-Security" class="headerlink" title="Image Security"></a>Image Security</h1><h2 id="✅-使用私有映像檔（Private-Image）"><a href="#✅-使用私有映像檔（Private-Image）" class="headerlink" title="✅ 使用私有映像檔（Private Image）"></a>✅ 使用私有映像檔（Private Image）</h2><p>登入私有 Registry 並使用 image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker login private-registry.io</span><br><span class="line">docker run private-registry.io/apps/internal-app</span><br></pre></td></tr></table></figure>

<p>建立可供 K8s 使用的 image pull secret</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create secret docker-registry regcred \</span><br><span class="line">  --docker-server=private-registry.io \</span><br><span class="line">  --docker-username=registry-user \</span><br><span class="line">  --docker-password=registry-password \</span><br><span class="line">  --docker-email=registry-user@org.com</span><br></pre></td></tr></table></figure>

<p>Pod 使用 imagePullSecrets 指定 Secret</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># nginx-pod.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">nginx-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">private-registry.io/apps/internal-app:v1.2.3</span></span><br><span class="line">      <span class="attr">imagePullPolicy:</span> <span class="string">IfNotPresent</span></span><br><span class="line">  <span class="attr">imagePullSecrets:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">regcred</span></span><br></pre></td></tr></table></figure>

<h2 id="imagePullPolicy-行為比較"><a href="#imagePullPolicy-行為比較" class="headerlink" title="imagePullPolicy 行為比較"></a>imagePullPolicy 行為比較</h2><p><code>imagePullPolicy</code> 是 Kubernetes Pod 中 container 的一個欄位，用來控制 Kubelet 什麼時候去拉（pull）image。它在部署與調試階段非常重要，尤其當你使用自建 image 或開發中頻繁更新的 image。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>行為說明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Always</code></td>
<td><strong>每次 Pod 啟動都會重新拉 image</strong>（不管本地有沒有）<br>通常用於 <code>:latest</code> image 或確保更新拉到最新</td>
</tr>
<tr>
<td><code>IfNotPresent</code></td>
<td><strong>只有當本地沒有對應 image 才會去拉</strong>（節省頻寬與啟動時間）</td>
</tr>
<tr>
<td><code>Never</code></td>
<td><strong>永遠不會去拉 image</strong>，只使用本地已有的 image，拉不到就會失敗（CI&#x2F;CD、測試環境有時會用）</td>
</tr>
</tbody></table>
<blockquote>
<p>預設值會依據 image 是否使用 <code>latest</code> 而變化：  </p>
<ul>
<li>使用 <code>:latest</code> → 預設為 <code>Always</code>  </li>
<li>指定其他 tag → 預設為 <code>IfNotPresent</code><br>✅ 為了可預測性，強烈建議永遠明確設定 <code>imagePullPolicy</code>。</li>
</ul>
</blockquote>
<p>查看 Pod 使用的 Image</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe pod mypod | grep Image</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Docker-Security-實務"><a href="#Docker-Security-實務" class="headerlink" title="Docker Security 實務"></a>Docker Security 實務</h1><h2 id="✅-使用非-root-user"><a href="#✅-使用非-root-user" class="headerlink" title="✅ 使用非 root user"></a>✅ 使用非 root user</h2><p>Dockerfile 中加入</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">USER</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>手動測試時也可以用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --user=1001 ubuntu <span class="built_in">sleep</span> 3600</span><br></pre></td></tr></table></figure>

<h2 id="✅-使用-capabilities-限制權限"><a href="#✅-使用-capabilities-限制權限" class="headerlink" title="✅ 使用 capabilities &#x2F; 限制權限"></a>✅ 使用 capabilities &#x2F; 限制權限</h2><p>添加特權能力（如 MAC_ADMIN）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --cap-add=MAC_ADMIN ubuntu</span><br></pre></td></tr></table></figure>

<p>移除某些能力（如 KILL）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --cap-drop=KILL ubuntu</span><br></pre></td></tr></table></figure>

<p>開啟完全特權模式（⚠️ 極高風險）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --privileged ubuntu</span><br></pre></td></tr></table></figure>
<blockquote>
<p>✅ 實務中，僅當應用需特殊權限（如操作網路 interface 或系統層設定）時才會加 capability，否則建議盡量精簡</p>
</blockquote>
<hr>
<h1 id="Security-Context"><a href="#Security-Context" class="headerlink" title="Security Context"></a>Security Context</h1><h2 id="✅-Pod-Level-設定"><a href="#✅-Pod-Level-設定" class="headerlink" title="✅ Pod Level 設定"></a>✅ Pod Level 設定</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">securityContext:</span></span><br><span class="line">    <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ubuntu</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3600&quot;</span>]</span><br></pre></td></tr></table></figure>

<h2 id="✅-Container-Level-設定"><a href="#✅-Container-Level-設定" class="headerlink" title="✅ Container Level 設定"></a>✅ Container Level 設定</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">web-pod</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">ubuntu</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">ubuntu</span></span><br><span class="line">      <span class="attr">command:</span> [<span class="string">&quot;sleep&quot;</span>, <span class="string">&quot;3600&quot;</span>]</span><br><span class="line">      <span class="attr">securityContext:</span></span><br><span class="line">        <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">        <span class="attr">capabilities:</span></span><br><span class="line">          <span class="attr">add:</span> [<span class="string">&quot;MAC_ADMIN&quot;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><mark>若在 Pod 與 Container 都有設定 <code>runAsUser</code>，以 Container 層級為主</mark></p>
</blockquote>
<div class="note info"><p>⚠️ 常見錯誤與實務注意事項</p>
<ul>
<li>若容器使用非 root 使用者，掛載 volume 時需確認目錄權限是否能寫入<ul>
<li>例：<code>/data</code> 目錄應設為 UID:1000 可寫</li>
</ul>
</li>
<li>建議 base image 本身已建立非 root 使用者<ul>
<li>例：<code>node:slim</code>, <code>nginx:alpine</code> 常已內建 user</li>
</ul>
</li>
</ul>
<br>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">securityContext:</span></span><br><span class="line">  <span class="attr">runAsUser:</span> <span class="number">1000</span></span><br><span class="line">  <span class="attr">runAsGroup:</span> <span class="number">3000</span></span><br><span class="line">  <span class="attr">fsGroup:</span> <span class="number">2000</span>  <span class="comment"># ✅ 掛載 volume 的群組權限自動對應</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>fsGroup</code> 可協助解決 volume 權限問題，尤其當容器非 root 且需寫入掛載目錄時</p>
</blockquote>
</div>

<hr>
<h1 id="CKA-考題可能怎麼出？"><a href="#CKA-考題可能怎麼出？" class="headerlink" title="CKA 考題可能怎麼出？"></a>CKA 考題可能怎麼出？</h1><p>☑️ 指定明確的 image tag（避免 latest）<br>☑️ 設定正確的 <code>imagePullPolicy</code><br>☑️ 處理 CrashLoopBackOff（image 拉不到）<br>☑️ Pod 運行失敗 → 判斷是否權限錯誤（non-root user 無法寫入）<br>☑️ 修改 YAML，設定 <code>securityContext</code>、指定 user、capabilities</p>
<blockquote>
<p>❗Dockerfile 本身不會考，但會用錯誤的 YAML 模擬出問題讓你 debug<br>💡 若 Pod CrashLoopBackOff，可使用 <code>kubectl logs</code> 與 <code>kubectl describe pod</code> 搭配排查</p>
</blockquote>
<hr>
<h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><ul>
<li>使用非 root 容器 + 明確 image tag 是安全基本原則</li>
<li>搭配 RBAC 與 Admission Controller 強化政策落實</li>
<li>熟悉 <code>securityContext</code> 在 Pod&#x2F;Container 不同層級的效果</li>
<li>CKA 考試更重視<strong>實作錯誤排查與安全配置能力</strong></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>CKA</tag>
        <tag>ImageSecurity</tag>
        <tag>SecurityContext</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Security | Authorization - ClusterRoles</title>
    <url>/2025/07/09/K8s-Advanced/K8s-Security-Authorization-ClusterRoles/</url>
    <content><![CDATA[<h1 id="ClusterRoles"><a href="#ClusterRoles" class="headerlink" title="ClusterRoles"></a>ClusterRoles</h1><p><code>ClusterRole</code> 和 <code>ClusterRoleBinding</code> 是 <strong>Cluster Scoped 資源</strong>，不屬於任何單一 namespace，可授權跨命名空間或整個叢集的資源，例如：</p>
<ul>
<li><code>nodes</code>、<code>namespaces</code>、<code>clusterroles</code>、<code>persistentvolumes</code> 等全域資源</li>
<li>可搭配 <code>RoleBinding</code> 使用於多個 namespace，達到重複授權</li>
</ul>
<h1 id="Namespaced-vs-Cluster-Scoped"><a href="#Namespaced-vs-Cluster-Scoped" class="headerlink" title="Namespaced vs Cluster Scoped"></a>Namespaced vs Cluster Scoped</h1><p>在 K8s 中，資源的作用範圍可分為兩大類：<strong>Namespaced（命名空間資源）</strong> 與 <strong>Cluster-scoped（叢集資源）</strong>。這個區分在設定權限（RBAC）、部署應用、管理資源時非常重要。</p>
<img src="/2025/07/09/K8s-Advanced/K8s-Security-Authorization-ClusterRoles/Namespaced_ClusterScoped.jpg" class="">

<table>
<thead>
<tr>
<th>授權類型</th>
<th>資源作用範圍</th>
<th>適用情境與實例</th>
</tr>
</thead>
<tbody><tr>
<td><code>Role</code> &#x2F; <code>RoleBinding</code></td>
<td>單一 namespace</td>
<td>一般應用程式權限（如 CRUD Pod）</td>
</tr>
<tr>
<td><code>ClusterRole</code> &#x2F; <code>RoleBinding</code></td>
<td>多個 namespace</td>
<td>ServiceAccount 跨命名空間權限</td>
</tr>
<tr>
<td><code>ClusterRole</code> &#x2F; <code>ClusterRoleBinding</code></td>
<td>全叢集（含全域資源）</td>
<td>管理 cluster-wide 資源，如 <code>nodes</code>、CRDs 等</td>
</tr>
</tbody></table>
<blockquote>
<p>📌 <code>ClusterRole</code> 可以透過 <code>RoleBinding</code> 授權給特定 namespace 中的使用者或 ServiceAccount。<br>✅ 這讓你可以重複使用同一個 <code>ClusterRole</code>，並以多個 <code>RoleBinding</code> 授權給不同命名空間，避免重複定義權限。</p>
</blockquote>
<h2 id="Namespaced-與-Cluster-scoped-資源範例"><a href="#Namespaced-與-Cluster-scoped-資源範例" class="headerlink" title="Namespaced 與 Cluster-scoped 資源範例"></a>Namespaced 與 Cluster-scoped 資源範例</h2><table>
<thead>
<tr>
<th>分類</th>
<th>說明</th>
<th>常見資源</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Namespaced</strong></td>
<td>僅存在於某個 namespace，適用於多租戶或資源隔離需求</td>
<td><code>pods</code>、<code>services</code>、<code>configmaps</code>、<code>secrets</code>、<code>role</code>、<code>rolebinding</code></td>
</tr>
<tr>
<td><strong>Cluster-scoped</strong></td>
<td>作用於整個叢集，<strong>不屬於任何 namespace</strong>，多用於核心管理資源</td>
<td><code>nodes</code>、<code>namespaces</code>、<code>persistentvolumes</code>、<code>clusterrole</code>、<code>clusterrolebinding</code>、<code>customresourcedefinition</code></td>
</tr>
</tbody></table>
<h2 id="RBAC-與資源範圍對應"><a href="#RBAC-與資源範圍對應" class="headerlink" title="RBAC 與資源範圍對應"></a>RBAC 與資源範圍對應</h2><table>
<thead>
<tr>
<th>權限組合</th>
<th>適用資源類型</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td><code>Role</code> + <code>RoleBinding</code></td>
<td>Namespaced 資源</td>
<td>精細控制單一 namespace 權限</td>
</tr>
<tr>
<td><code>ClusterRole</code> + <code>RoleBinding</code></td>
<td>Cluster &#x2F; Namespaced</td>
<td>跨 namespace 重用 ClusterRole 權限</td>
</tr>
<tr>
<td><code>ClusterRole</code> + <code>ClusterRoleBinding</code></td>
<td>Cluster-scoped 資源</td>
<td>適用於 cluster-wide 資源授權</td>
</tr>
</tbody></table>
<h2 id="範例比對表"><a href="#範例比對表" class="headerlink" title="範例比對表"></a>範例比對表</h2><table>
<thead>
<tr>
<th>資源</th>
<th>作用範圍</th>
<th>需使用哪種角色控制</th>
</tr>
</thead>
<tbody><tr>
<td><code>pods</code></td>
<td>Namespaced</td>
<td>Role &#x2F; RoleBinding</td>
</tr>
<tr>
<td><code>nodes</code></td>
<td>Cluster-scoped</td>
<td>ClusterRole &#x2F; ClusterRoleBinding</td>
</tr>
<tr>
<td><code>configmaps</code></td>
<td>Namespaced</td>
<td>Role</td>
</tr>
<tr>
<td><code>namespaces</code></td>
<td>Cluster-scoped</td>
<td>ClusterRole</td>
</tr>
<tr>
<td><code>secrets</code></td>
<td>Namespaced</td>
<td>Role</td>
</tr>
<tr>
<td><code>customresourcedefinitions</code></td>
<td>Cluster-scoped</td>
<td>ClusterRole</td>
</tr>
</tbody></table>
<hr>
<h1 id="建立與操作指令"><a href="#建立與操作指令" class="headerlink" title="建立與操作指令"></a>建立與操作指令</h1><h2 id="建立-ClusterRole"><a href="#建立-ClusterRole" class="headerlink" title="建立 ClusterRole"></a>建立 ClusterRole</h2><h3 id="cluster-admin-role-yaml"><a href="#cluster-admin-role-yaml" class="headerlink" title="cluster-admin-role.yaml"></a>cluster-admin-role.yaml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-administrator</span></span><br><span class="line"><span class="attr">rules:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">apiGroups:</span> [<span class="string">&quot;&quot;</span>]</span><br><span class="line">  <span class="attr">resources:</span> [<span class="string">&quot;nodes&quot;</span>]</span><br><span class="line">  <span class="attr">verbs:</span> [<span class="string">&quot;list&quot;</span>, <span class="string">&quot;get&quot;</span>, <span class="string">&quot;create&quot;</span>, <span class="string">&quot;update&quot;</span>, <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;watch&quot;</span>]</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>watch</code>：用於監控資源變化，常見於 Controller &#x2F; Operator</p>
</blockquote>
<h3 id="Kubectl-建立指令"><a href="#Kubectl-建立指令" class="headerlink" title="Kubectl 建立指令"></a>Kubectl 建立指令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f cluster-admin-role.yaml</span><br></pre></td></tr></table></figure>

<h2 id="建立-ClusterRoleBinding"><a href="#建立-ClusterRoleBinding" class="headerlink" title="建立 ClusterRoleBinding"></a>建立 ClusterRoleBinding</h2><blockquote>
<p>⚠️ 使用 <code>ClusterRoleBinding</code> 時會影響整個叢集資源，<strong>一旦授權過寬，可能導致重大安全風險</strong>，請務必審慎評估。<br>✅ 可搭配 OPA&#x2F;Gatekeeper 實施「限制性授權政策」（如禁止 * verbs 或 * resources）。<br>💡 <mark>若只需授權特定 namespace 的權限，請優先使用 <code>RoleBinding + ClusterRole</code> 即可。</mark></p>
</blockquote>
<h3 id="cluster-admin-role-yaml-1"><a href="#cluster-admin-role-yaml-1" class="headerlink" title="cluster-admin-role.yaml"></a>cluster-admin-role.yaml</h3><p>同上</p>
<h3 id="cluster-admin-role-binding-yaml"><a href="#cluster-admin-role-binding-yaml" class="headerlink" title="cluster-admin-role-binding.yaml"></a>cluster-admin-role-binding.yaml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin-role-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">User</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-admin</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-administrator</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<h3 id="Kubectl-建立指令-1"><a href="#Kubectl-建立指令-1" class="headerlink" title="Kubectl 建立指令"></a>Kubectl 建立指令</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create -f cluster-admin-role-binding.yaml</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="補充：ServiceAccount-綁定範例"><a href="#補充：ServiceAccount-綁定範例" class="headerlink" title="補充：ServiceAccount 綁定範例"></a>補充：ServiceAccount 綁定範例</h1><p>若你希望某個 Pod 所使用的 ServiceAccount 擁有跨 namespace 的權限，可以這樣建立：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># cluster-role-binding-serviceaccount.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">backend-access-nodes</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">app-ns</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">cluster-administrator</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="權限驗證與偵錯"><a href="#權限驗證與偵錯" class="headerlink" title="權限驗證與偵錯"></a>權限驗證與偵錯</h1><h2 id="查詢現有-ClusterRole-ClusterRoleBinding"><a href="#查詢現有-ClusterRole-ClusterRoleBinding" class="headerlink" title="查詢現有 ClusterRole &#x2F; ClusterRoleBinding"></a>查詢現有 ClusterRole &#x2F; ClusterRoleBinding</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get clusterroles</span><br><span class="line">kubectl get clusterrolebindings</span><br></pre></td></tr></table></figure>

<h2 id="驗證使用者是否有權限"><a href="#驗證使用者是否有權限" class="headerlink" title="驗證使用者是否有權限"></a>驗證使用者是否有權限</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl auth can-i [verb] [resource] --as [user] --namespace [ns]</span><br><span class="line"></span><br><span class="line">kubectl auth can-i create nodes --as cluster-admin</span><br><span class="line">kubectl auth can-i get    nodes --as system:serviceaccount:app-ns:backend</span><br><span class="line"><span class="comment"># 回傳 &quot;yes&quot; 表示有權限，&quot;no&quot; 表示被拒絕</span></span><br></pre></td></tr></table></figure>

<h2 id="查詢資源範圍屬性-👍"><a href="#查詢資源範圍屬性-👍" class="headerlink" title="查詢資源範圍屬性 👍"></a>查詢資源範圍屬性 👍</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl api-resources --namespaced=<span class="literal">true</span>   <span class="comment"># 顯示所有 namespaced 資源</span></span><br><span class="line">kubectl api-resources --namespaced=<span class="literal">false</span>  <span class="comment"># 顯示所有 cluster-scoped 資源</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><ul>
<li><code>ClusterRole</code> 適用於授權跨 namespace 或 cluster-wide 資源存取。</li>
<li><code>ClusterRoleBinding</code> 是全叢集生效，需謹慎授權。</li>
<li>若使用者只需在 namespace 操作，建議使用 <code>RoleBinding + ClusterRole</code>。</li>
<li>若有跨 namespace 需求：<ul>
<li><code>ClusterRole + RoleBinding</code>：適用於 <code>跨 namespace</code> 重複授權相同權限</li>
<li><code>ClusterRole + ClusterRoleBinding</code>（統一授權全域資源）：適用於需要 <code>全叢集資源控制的管理者</code></li>
</ul>
</li>
<li>常搭配 <code>kubectl auth can-i</code> 指令驗證權限，避免授權錯誤。</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>ClusterRoles</tag>
        <tag>ClusterRoleBinding</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s | Cluster Maintenance</title>
    <url>/2025/06/13/K8s-Advanced/K8s-Cluster-Maintenance/</url>
    <content><![CDATA[<h1 id="OS-Upgrades"><a href="#OS-Upgrades" class="headerlink" title="OS Upgrades"></a>OS Upgrades</h1><h2 id="重要指令"><a href="#重要指令" class="headerlink" title="重要指令"></a>重要指令</h2><h3 id="kubectl-drain"><a href="#kubectl-drain" class="headerlink" title="kubectl drain &lt;NODE_NAME&gt;"></a>kubectl drain &lt;NODE_NAME&gt;</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl drain node01 --ignore-daemonsets</span><br></pre></td></tr></table></figure>
<p>將 K8s Cluster 中的 node01 節點進行「排空」操作，也就是把 node01 上的 Pod (所有非 DaemonSet 的 Pod) 移開或刪除，以便進行維護或更新。</p>
<details class="note default"><summary><p>補充說明：kubectl drain</p>
</summary>
<p><mark>預設會做什麼？</mark></p>
<ol>
<li>將節點標記為 unschedulable：<ul>
<li>相當於執行 <code>kubectl cordon node01</code></li>
<li>表示新的 Pod 不會再被排程到這個 node 上</li>
</ul>
</li>
<li>驅逐(刪除) old node 上的非 DaemonSet Pod：<ul>
<li>將這些 Pod 標記為 Evicted，並由其 Controller（如 Deployment、StatefulSet）自動在其他節點重新部署</li>
</ul>
</li>
<li>不處理以下 Pod 類型 (除非加入額外參數)：<ul>
<li>DaemonSet Pod (除非加入 –delete-emptydir-data)</li>
<li>Mirror Pod (靜態 Pod)</li>
<li>Unmanaged Pod（沒有 controller，例如未由 ReplicaSet 管理的 Pod）</li>
</ul>
</li>
</ol>
<p><mark>相關補充：</mark></p>
<ol>
<li><code>--grace-period=SECONDS</code>（Pod 優雅終止時間）<ul>
<li>影響單一 Pod 被刪除前等待多久讓其優雅終止（執行清理邏輯）。</li>
<li>預設值：來自 Pod 的 terminationGracePeriodSeconds（通常為 30 秒）。</li>
<li>✅ 可透過 <code>kubectl drain node01 --grace-period=10</code> 指定。</li>
</ul>
</li>
<li><code>--pod-eviction-timeout=TIME</code>（節點失效時的驅逐等待時間）<ul>
<li>是 kube-controller-manager 的參數，控制當節點 NotReady 或 Unreachable 時，K8s 等多久才會驅逐該 node 上的 Pod。</li>
<li>預設值：5 分鐘。</li>
<li>✅ 僅在節點異常（自動驅逐）時生效，與 kubectl drain 無關。</li>
</ul>
</li>
</ol>
<p><mark>常見用途：</mark></p>
<ol>
<li>節點維修（硬體更換、OS 升級）</li>
<li>安全性修補（Patching）</li>
<li>節點關機或重啟</li>
<li>滾動更新 OS 或 kubelet</li>
</ol>

</details>

<h3 id="kubectl-cordon"><a href="#kubectl-cordon" class="headerlink" title="kubectl cordon &lt;NODE_NAME&gt;"></a>kubectl cordon &lt;NODE_NAME&gt;</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl cordon node02</span><br></pre></td></tr></table></figure>
<p>將 node02 標記為 unschedulable (只封鎖排程)，不移除任何 Pod。</p>
<details class="note default"><summary><p>補充說明：kubectl cordon</p>
</summary>
<p><mark>使用情境：</mark></p>
<ul>
<li>當你只想停止新的 Pod 被安排到此 node，但不想驅逐目前 node 上的 Pod 時。</li>
</ul>

</details>

<h3 id="kubectl-uncordon"><a href="#kubectl-uncordon" class="headerlink" title="kubectl uncordon &lt;NODE_NAME&gt;"></a>kubectl uncordon &lt;NODE_NAME&gt;</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl uncordon node01</span><br></pre></td></tr></table></figure>
<p>解除 node 封鎖 (恢復可調度狀態)，允許排程 (新的 Pod 被 schedule 到 node 上)。</p>
<details class="note default"><summary><p>補充說明：kubectl uncordon</p>
</summary>
<p><mark>使用情境：</mark></p>
<ul>
<li>你已經完成 node01 的維護作業 (例如系統更新、重啟、硬體修復)。你想要讓 node01 恢復正常調度時。</li>
</ul>

</details>

<h3 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h3><div class="note info"><p><strong>背景知識：</strong></p>
<ol>
<li><em>當你使用 <code>kubectl drain node01</code> 排空 node 時，它會同時把 node 標記為不可調度（unschedulable），以避免有新 Pod 被分派至該機器。</em></li>
<li><em>使用 uncordon 則是「恢復調度」功能，讓 node 可以再次承擔新的 Pod 排程任務。</em></li>
</ol>
<p><strong>總結：</strong></p>
<ul>
<li><code>kubectl drain</code> &#x3D; 封鎖排程 + 驅逐非 DaemonSet Pod</li>
<li><code>kubectl cordon</code> &#x3D; 僅封鎖排程，不移動 Pod</li>
<li><code>kubectl uncordon</code> &#x3D; 恢復排程功能</li>
</ul>
<p><strong>建議搭配下面指令觀察節點狀態：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o wide</span><br><span class="line">kubectl describe node node01</span><br></pre></td></tr></table></figure></div>

<p>在 Kubernetes 中進行 OS 升級（例如 Ubuntu、CentOS、RHEL、Amazon Linux 等）時，為了最小化服務中斷，建議採取 <strong>滾動升級（Rolling Upgrade）</strong> 策略，確保集群持續可用。</p>
<ol>
<li>升級前準備<ul>
<li>檢查節點狀態<br><code>kubectl get nodes -o wide</code></li>
<li>標記節點為不可調度（防止新 Pod 被排到這台機器）<br><code>kubectl cordon &lt;NODE_NAME&gt;</code></li>
<li>排空節點（移除現有 Pod）<br><code>kubectl drain &lt;NODE_NAME&gt; --ignore-daemonsets --delete-emptydir-data</code><blockquote>
<p>–ignore-daemonsets：保留 DaemonSet pod<br>–delete-emptydir-data：允許刪除使用 emptyDir 的 Pod</p>
</blockquote>
</li>
</ul>
</li>
<li>升級作業系統<ul>
<li>Ubuntu 範例<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt update &amp;&amp; sudo apt upgrade -y</span><br><span class="line">sudo reboot</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>重啟後驗證與重新加入節點<ul>
<li>驗證節點狀態：節點應該會從 NotReady 回到 Ready 狀態。<br><code>kubectl get nodes</code></li>
<li>允許排程回該節點<br><code>kubectl uncordon &lt;NODE_NAME&gt;</code></li>
</ul>
</li>
<li>針對其他節點重複此流程<ul>
<li>建議依序進行每個節點，確保系統與服務不中斷。</li>
</ul>
</li>
</ol>
<hr>
<h1 id="K8s-Releases"><a href="#K8s-Releases" class="headerlink" title="K8s Releases"></a>K8s Releases</h1><h2 id="重要指令-1"><a href="#重要指令-1" class="headerlink" title="重要指令"></a>重要指令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>

<h2 id="版本解析"><a href="#版本解析" class="headerlink" title="版本解析"></a>版本解析</h2><blockquote>
<p><a href="https://github.com/kubernetes/kubernetes/releases">Kubernetes&#x2F;releases</a></p>
</blockquote>
<p>v1.11.3</p>
<ul>
<li>v1: Major (重大架構變動，極少變動)</li>
<li>11: Minor (Features, Functionalities)</li>
<li>3:  Patch (Bug Fixes)</li>
</ul>
<h2 id="K8s-component-升級策略-–-版本選擇"><a href="#K8s-component-升級策略-–-版本選擇" class="headerlink" title="K8s component 升級策略 – 版本選擇"></a>K8s component 升級策略 – 版本選擇</h2><p><mark>kubeadm 的版本必須「等於或高於」你要升級的 Kubernetes cluster 版本</mark><br><mark>Kubernetes 官方僅支援 <code>最近三個「Minor」版本</code>（N、N-1、N-2）</mark></p>
<table>
<thead>
<tr>
<th>最新版本（N）</th>
<th>同時支援的版本</th>
</tr>
</thead>
<tbody><tr>
<td>v1.30</td>
<td>v1.30, v1.29, v1.28</td>
</tr>
<tr>
<td>v1.29</td>
<td>v1.29, v1.28, v1.27</td>
</tr>
</tbody></table>
<p>也就是說：</p>
<ul>
<li><mark>只有最近三個 minor 版本會獲得官方的 patch 更新與安全修復。</mark></li>
<li>每個版本的支援週期約為 1 年（每個版本約每 3~4 個月發佈一次）。</li>
</ul>
<div class="note info"><p>ETCD CLUSTER</p>
<ul>
<li>通常由 kubeadm upgrade 管理，支援升級前備份</li>
<li>版本不能跳太多，應查閱官方 <a href="https://etcd.io/docs/v3.6/upgrades/">etcd 升級指南</a></li>
</ul>
<p>CoreDNS</p>
<ul>
<li>升級過程中 kubeadm 會提示是否升級</li>
<li>使用者需手動確認是否升級</li>
</ul>
<p>Kubernetes 元件版本相容性 (以 kube-apiserver 版本為準，X &#x3D; v1.10)</p>
<table>
<thead>
<tr>
<th>元件</th>
<th>建議版本範圍</th>
</tr>
</thead>
<tbody><tr>
<td>Controller-manager、kube-scheduler</td>
<td>X 或 X-1（例：v1.9 或 v1.10）</td>
</tr>
<tr>
<td>kubelet、kube-proxy</td>
<td>X、X-1、X-2（例：v1.8 或 v1.9 或 v1.10）</td>
</tr>
<tr>
<td>kubectl</td>
<td>X-1、X、X+1（例：v1.9 或 v1.10 或 v1.11）</td>
</tr>
</tbody></table>
</div>

<hr>
<h1 id="Cluster-Upgrade-Process"><a href="#Cluster-Upgrade-Process" class="headerlink" title="Cluster Upgrade Process"></a>Cluster Upgrade Process</h1><p>在 Kubernetes 的升級流程中，應該先從 Control Plane（master 節點）開始升級，再升級 worker 節點。</p>
<ul>
<li><a href="https://kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">Docs: Upgrading control plane nodes</a></li>
<li><a href="https://v1-32.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/upgrading-linux-nodes/">Docs: Upgrading worker nodes</a></li>
</ul>
<p><mark>在 Kubernetes 中，升級（Upgrade）是單向的流程，一旦升級完成就 ⚠️ 無法直接降版（Downgrade）。</mark></p>
<h2 id="重要指令-2"><a href="#重要指令-2" class="headerlink" title="重要指令"></a>重要指令</h2><h3 id="kubectl-get-nodes"><a href="#kubectl-get-nodes" class="headerlink" title="kubectl get nodes"></a>kubectl get nodes</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure>
<p>Get current version of the cluster.</p>
<h3 id="kubeadm-upgrade-plan"><a href="#kubeadm-upgrade-plan" class="headerlink" title="kubeadm upgrade plan"></a>kubeadm upgrade plan</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm upgrade plan</span><br></pre></td></tr></table></figure>
<p>查看目前升級計畫<br>可知 Cluster version、kubeadm version、Latest stable version …</p>
<h3 id="kubeadm-upgrade-apply"><a href="#kubeadm-upgrade-apply" class="headerlink" title="kubeadm upgrade apply"></a>kubeadm upgrade apply</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm upgrade apply</span><br></pre></td></tr></table></figure>
<p>執行升級，升級 Control Plane 節點（只做 master）</p>
<h2 id="✅-升級順序"><a href="#✅-升級順序" class="headerlink" title="✅ 升級順序"></a>✅ 升級順序</h2><ol>
<li><a href="https://v1-32.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/kubeadm-upgrade/">升級 Control Plane（Master）節點</a><ul>
<li>包括 kube-apiserver、controller-manager、scheduler、etcd<br> Step 0：前置檢查 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes</span><br><span class="line">kubectl version</span><br><span class="line">kubeadm version</span><br><span class="line">vim /etc/apt/sources.list.d/kubernetes.list</span><br></pre></td></tr></table></figure>
 Step 1：升級 kubeadm 工具（本機） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 更新 apt 索引</span></span><br><span class="line">sudo apt-get update</span><br><span class="line"><span class="comment"># 列出你目前系統從 apt 套件來源可以抓到的所有 kubeadm 版本</span></span><br><span class="line">sudo apt-cache madison kubeadm</span><br><span class="line"></span><br><span class="line"><span class="comment"># 安裝指定版本 kubeadm</span></span><br><span class="line">sudo apt-get install -y kubeadm=<span class="string">&#x27;1.32.0-1.1&#x27;</span></span><br></pre></td></tr></table></figure>
 Step 2：模擬升級計畫 (預覽) + 套用升級  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubeadm upgrade plan</span><br><span class="line">kubeadm upgrade apply v1.32.0</span><br></pre></td></tr></table></figure>
 Step 3：升級 kubelet 與 kubectl <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install -y kubelet=<span class="string">&#x27;1.32.0-1.1&#x27;</span> kubectl=<span class="string">&#x27;1.32.0-1.1&#x27;</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart kubelet</span><br></pre></td></tr></table></figure>
 Step 4：Verify the status of the cluster <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o wide</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><a href="https://v1-32.docs.kubernetes.io/docs/tasks/administer-cluster/kubeadm/upgrading-linux-nodes/">升級 Worker 節點</a><ul>
<li>包括 kubelet、kube-proxy、OS<br> Step 0：排空節點 (Drain) <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl drain &lt;worker-node&gt; --ignore-daemonsets</span><br></pre></td></tr></table></figure>
 Step 1：進入該 Worker 節點，升級 kubeadm 工具 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh node01</span><br><span class="line"></span><br><span class="line"><span class="comment"># 確保來源正確（只需設定一次）</span></span><br><span class="line">vim /etc/apt/sources.list.d/kubernetes.list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更新套件資訊並安裝 kubeadm v1.32.0</span></span><br><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y kubeadm=<span class="string">&#x27;1.32.0-1.1&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查實際版本</span></span><br><span class="line">apt-cache madison kubeadm</span><br></pre></td></tr></table></figure>
 Step 2：升級 kubeadm<br> 對於 Worker 節點，只需要這個命令即可（不需 apply，那是 Control Plane 用的） <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo kubeadm upgrade node</span><br></pre></td></tr></table></figure>
 Step 3：升級 kubelet 與 kubectl 並重啟服務 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get update &amp;&amp; sudo apt-get install -y kubelet=<span class="string">&#x27;1.32.0-1.1&#x27;</span> kubectl=<span class="string">&#x27;1.32.0-1.1&#x27;</span></span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart kubelet</span><br><span class="line"><span class="built_in">exit</span></span><br></pre></td></tr></table></figure>
 Step 4：Verify the status of the cluster (on Control Plane node) <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get nodes -o wide</span><br></pre></td></tr></table></figure>
 Step 5：取消排空 (Uncordon) <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl uncordon &lt;worker-node&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ol>
<div class="note info"><p><strong>為什麼要先升級 Control Plane？</strong></p>
<ul>
<li>Control Plane 決定 Cluster API 行為與版本邏輯，所有 worker 節點都必須與 apiserver 相容。</li>
<li>worker 節點允許落後最多 2 個版本（X-2），但 Control Plane 通常不能落後 worker。</li>
<li>先升級 worker 可能導致不相容的 kubelet 版本 → apiserver 拒絕通信。</li>
</ul>
<p><strong>實務注意事項</strong></p>
<ul>
<li>多個 master 節點時，<code>一台一台升級</code>，可保持 HA（高可用）不中斷。</li>
<li>可透過 kubectl get nodes 檢查版本，搭配 kubeadm upgrade plan 來規劃升級路線。</li>
<li>升級前 <code>備份 etcd</code> 是很好的保險措施。</li>
</ul>
</div>

<h2 id="Upgrade-Strategy-3-種方式"><a href="#Upgrade-Strategy-3-種方式" class="headerlink" title="Upgrade Strategy (3 種方式)"></a>Upgrade Strategy (3 種方式)</h2><ol>
<li>一次升級所有節點（會停機）<ul>
<li>適合情境：測試環境、非高可用架構</li>
<li>優點：快速簡單</li>
<li>缺點：服務停機</li>
</ul>
</li>
<li>輪流升級現有節點 (不中斷服務)<blockquote>
<p>一個 Upgrade 完，再換下一個 Upgrade (沒有新增 node，直接用現有的 node 進行)</p>
</blockquote>
<ul>
<li>適合情境：小規模、可接受稍微波動</li>
<li>優點：不需擴容</li>
<li>缺點：升級期間有壓力</li>
</ul>
</li>
<li>新節點接手、移除舊節點 (先加新節點升級 → 移動應用 → 移除舊節點)<blockquote>
<p>先新增一個 Upgrade 後的 node，把 application 放到該 Upgrade 後的 node 上運行，再把舊 node 砍掉 (有新增 node)</p>
</blockquote>
<ul>
<li>適合情境：大型企業、高可用要求</li>
<li>優點：無中斷、可測試新節點</li>
<li>缺點：成本較高、需備援資源</li>
</ul>
</li>
</ol>
<hr>
<h1 id="Backup-and-Restore"><a href="#Backup-and-Restore" class="headerlink" title="Backup and Restore"></a>Backup and Restore</h1><ul>
<li>Backup 範圍<ul>
<li>Resource Configuration：所有 K8s 資源設定檔（Deployment、Service、Secrets）</li>
<li>ETCD Cluster：儲存整個 Cluster 狀態（control plane source of truth）</li>
<li>Persistent Volumes：PV&#x2F;PVC（取決於是否使用支援 snapshot 的 StorageClass）</li>
</ul>
</li>
</ul>
<h2 id="重要指令-3"><a href="#重要指令-3" class="headerlink" title="重要指令"></a>重要指令</h2><h3 id="Backup-Resource-Configuration"><a href="#Backup-Resource-Configuration" class="headerlink" title="Backup - Resource Configuration"></a>Backup - Resource Configuration</h3><h4 id="✅-Imperative-建立資源"><a href="#✅-Imperative-建立資源" class="headerlink" title="✅ Imperative 建立資源"></a>✅ Imperative 建立資源</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create namespace &lt;name&gt;</span><br><span class="line"></span><br><span class="line">kubectl create secret generic &lt;name&gt; --from-literal=password=mypassword</span><br><span class="line"></span><br><span class="line">kubectl create configmap &lt;name&gt; --from-literal=key=value</span><br></pre></td></tr></table></figure>

<h4 id="✅-Declarative-建立資源"><a href="#✅-Declarative-建立資源" class="headerlink" title="✅ Declarative 建立資源"></a>✅ Declarative 建立資源</h4><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># pod-definition.yml</span></span><br><span class="line"></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply –f pod-definition.yml</span><br></pre></td></tr></table></figure>

<h4 id="✅-將所有資源匯出成-YAML-🌟"><a href="#✅-將所有資源匯出成-YAML-🌟" class="headerlink" title="✅ 將所有資源匯出成 YAML 🌟"></a>✅ 將所有資源匯出成 YAML 🌟</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get all --all-namespaces -o yaml &gt; all-resources.yaml</span><br><span class="line">kubectl get configmap,secret --all-namespaces -o yaml &gt; config-secret.yaml</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 補充：也可以逐一備份各資源種類</span></span><br><span class="line">kubectl get deployments.apps --all-namespaces -o yaml &gt; deployments.yaml</span><br><span class="line">kubectl get svc --all-namespaces -o yaml &gt; services.yaml</span><br></pre></td></tr></table></figure>

<h3 id="Backup-ETCD-ETCD-Cluster-Snapshot"><a href="#Backup-ETCD-ETCD-Cluster-Snapshot" class="headerlink" title="Backup - ETCD (ETCD Cluster) Snapshot"></a>Backup - ETCD (ETCD Cluster) Snapshot</h3><h4 id="✅-方式一：使用-etcdctl（Snapshot-based-Backup，推薦）🌟"><a href="#✅-方式一：使用-etcdctl（Snapshot-based-Backup，推薦）🌟" class="headerlink" title="✅ 方式一：使用 etcdctl（Snapshot-based Backup，推薦）🌟"></a>✅ 方式一：使用 etcdctl（Snapshot-based Backup，推薦）🌟</h4><blockquote>
<p>To take a snapshot from a running etcd server</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">  --endpoints=https://127.0.0.1:2379 \</span><br><span class="line">  --cacert=/etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">  --cert=/etc/kubernetes/pki/etcd/server.crt \</span><br><span class="line">  --key=/etc/kubernetes/pki/etcd/server.key \</span><br><span class="line">  snapshot save /backup/etcd-snapshot.db</span><br></pre></td></tr></table></figure>

<p>範例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe pod etcd-controlplane -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># Command:</span></span><br><span class="line"><span class="comment">#       etcd</span></span><br><span class="line"><span class="comment">#       --advertise-client-urls=https://192.168.42.128:2379</span></span><br><span class="line"><span class="comment"># V     --cert-file=/etc/kubernetes/pki/etcd/server.crt</span></span><br><span class="line"><span class="comment">#       --client-cert-auth=true</span></span><br><span class="line"><span class="comment">#       --data-dir=/var/lib/etcd</span></span><br><span class="line"><span class="comment">#       --experimental-initial-corrupt-check=true</span></span><br><span class="line"><span class="comment">#       --experimental-watch-progress-notify-interval=5s</span></span><br><span class="line"><span class="comment">#       --initial-advertise-peer-urls=https://192.168.42.128:2380</span></span><br><span class="line"><span class="comment">#       --initial-cluster=controlplane=https://192.168.42.128:2380</span></span><br><span class="line"><span class="comment"># V     --key-file=/etc/kubernetes/pki/etcd/server.key</span></span><br><span class="line"><span class="comment">#       --listen-client-urls=https://127.0.0.1:2379,https://192.168.42.128:2379</span></span><br><span class="line"><span class="comment">#       --listen-metrics-urls=http://127.0.0.1:2381</span></span><br><span class="line"><span class="comment">#       --listen-peer-urls=https://192.168.42.128:2380</span></span><br><span class="line"><span class="comment">#       --name=controlplane</span></span><br><span class="line"><span class="comment">#       --peer-cert-file=/etc/kubernetes/pki/etcd/peer.crt</span></span><br><span class="line"><span class="comment">#       --peer-client-cert-auth=true</span></span><br><span class="line"><span class="comment">#       --peer-key-file=/etc/kubernetes/pki/etcd/peer.key</span></span><br><span class="line"><span class="comment">#       --peer-trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt</span></span><br><span class="line"><span class="comment">#       --snapshot-count=10000</span></span><br><span class="line"><span class="comment"># V     --trusted-ca-file=/etc/kubernetes/pki/etcd/ca.crt</span></span><br><span class="line"></span><br><span class="line">ETCDCTL_API=3 etcdctl \</span><br><span class="line">  snapshot save /opt/snapshot-pre-boot.db \</span><br><span class="line">  --cacert /etc/kubernetes/pki/etcd/ca.crt \</span><br><span class="line">  --cert /etc/kubernetes/pki/etcd/server.crt \</span><br><span class="line">  --key /etc/kubernetes/pki/etcd/server.key</span><br></pre></td></tr></table></figure>
<ul>
<li><code>--endpoints</code>: Optional Flag, points to the address where ETCD is running (127.0.0.1:2379)</li>
<li><code>--cacert</code> Mandatory Flag (Absolute Path to the CA certificate file)</li>
<li><code>--cert</code> pMandatory Flag (Absolute Path to the Server certificate file)</li>
<li><code>--key</code> Mandatory Flag (Absolute Path to the Key file)</li>
</ul>
<p>確認快照狀態：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ETCDCTL_API=3 etcdctl snapshot status /backup/etcd-snapshot.db \</span><br><span class="line">  --write-out=table</span><br></pre></td></tr></table></figure>

<h4 id="✅-方式二：使用-etcdutl（File-based-Backup，需停機）"><a href="#✅-方式二：使用-etcdutl（File-based-Backup，需停機）" class="headerlink" title="✅ 方式二：使用 etcdutl（File-based Backup，需停機）"></a>✅ 方式二：使用 etcdutl（File-based Backup，需停機）</h4><blockquote>
<p>For offline file-level backup of the data directory</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">etcdutl backup \</span><br><span class="line">  --data-dir /var/lib/etcd \</span><br><span class="line">  --backup-dir /backup/etcd-backup</span><br></pre></td></tr></table></figure>

<h3 id="Restore-ETCD-ETCD-Cluster-Snapshot"><a href="#Restore-ETCD-ETCD-Cluster-Snapshot" class="headerlink" title="Restore - ETCD (ETCD Cluster) Snapshot"></a>Restore - ETCD (ETCD Cluster) Snapshot</h3><p>⚠️ 還原動作會覆蓋原有資料，請審慎執行！</p>
<h4 id="✅-還原-snapshot（建立新-etcd-data-dir）"><a href="#✅-還原-snapshot（建立新-etcd-data-dir）" class="headerlink" title="✅ 還原 snapshot（建立新 etcd data-dir）"></a>✅ 還原 snapshot（建立新 etcd data-dir）</h4><blockquote>
<p>To restore a snapshot to a new data directory</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 停止 kube-apiserver，避免競爭 etcd socket</span></span><br><span class="line">systemctl stop kube-apiserver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 etcdctl 還原 snapshot 到新目錄（不覆蓋原目錄）</span></span><br><span class="line">ETCDCTL_API=3 etcdctl snapshot restore /backup/etcd-snapshot.db \</span><br><span class="line">  --data-dir /var/lib/etcd-from-backup \</span><br><span class="line">  --initial-cluster master-1=https://192.168.5.11:2380,master-2=https://192.168.5.12:2380 \ → 多節點（HA etcd cluster）</span><br><span class="line">  --initial-cluster-token etcd-cluster-1 \</span><br><span class="line">  --initial-advertise-peer-urls https://192.168.5.11:2380</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改 etcd.yaml (Static Pod) 使用新的 data-dir（/var/lib/etcd-from-backup）</span></span><br><span class="line">vim /etc/kubernetes/manifests/etcd.yaml</span><br><span class="line"><span class="comment"># 找到 --data-dir 改為 /var/lib/etcd-from-backup</span></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">  <span class="comment"># volumes:</span></span><br><span class="line">  <span class="comment"># - hostPath:</span></span><br><span class="line">  <span class="comment">#     path: /var/lib/etcd-from-backup # New restored backup directory</span></span><br><span class="line">  <span class="comment">#     type: DirectoryOrCreate</span></span><br><span class="line">  <span class="comment">#   name: etcd-data</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 重載並觀察 etcd / kube-apiserver 重啟狀況</span></span><br><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl restart etcd</span><br><span class="line">systemctl start kube-apiserver</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 監看容器啟動</span></span><br><span class="line">watch crictl ps</span><br><span class="line">kubectl get deployments,services --all-namespaces</span><br></pre></td></tr></table></figure>

<div class="note info"><p>Check the image used by the ETCD pod</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Method 1</span></span><br><span class="line">kubectl describe pod etcd-controlplane -n kube-system</span><br><span class="line"></span><br><span class="line"><span class="comment"># Method 2</span></span><br><span class="line">kubeadm upgrade plan</span><br></pre></td></tr></table></figure></div>

<hr>
<h1 id="K8s-Architecture"><a href="#K8s-Architecture" class="headerlink" title="K8s Architecture"></a>K8s Architecture</h1><ul>
<li>Master<ul>
<li>用途：Manage, Plan, Schedule, Monitor Nodes</li>
<li>元件：ETCD CLUSTER, kube-apiserver, kube-scheduler, Kube Controller Manager</li>
</ul>
</li>
<li>Worker Nodes<ul>
<li>用途：Host Application as Containers</li>
<li>元件：kubelet, Kube-proxy, Container Runtime Engine (如 containerd)</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>OS Upgrades</tag>
        <tag>Backup</tag>
        <tag>Restore</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Security | CA</title>
    <url>/2025/07/07/K8s-Advanced/K8s-Security-CA/</url>
    <content><![CDATA[<h1 id="K8s-CA-與-CSR-憑證簽署流程"><a href="#K8s-CA-與-CSR-憑證簽署流程" class="headerlink" title="K8s CA 與 CSR 憑證簽署流程"></a>K8s CA 與 CSR 憑證簽署流程</h1><h2 id="什麼是-CA-Certificate-Authority-？"><a href="#什麼是-CA-Certificate-Authority-？" class="headerlink" title="什麼是 CA (Certificate Authority)？"></a>什麼是 CA (Certificate Authority)？</h2><p>K8s 使用內建的 Certificate Authority（CA）簽發憑證給用戶、元件或服務，透過自動化控制流程來統一管理：</p>
<ol>
<li>簽署元件憑證（如 API Server、kubelet）</li>
<li>驗證 Client 憑證（RBAC、API 請求）</li>
<li>使用 Certificates API 自動化 CSR (CertificateSigningRequest) 流程</li>
</ol>
<h2 id="CSR-CertificateSigningRequest-操作流程"><a href="#CSR-CertificateSigningRequest-操作流程" class="headerlink" title="CSR (CertificateSigningRequest) 操作流程"></a>CSR (CertificateSigningRequest) 操作流程</h2><p>CSR 的簽署與核准流程，是由 kube-controller-manager 內部的 controller 自動完成。你可以透過 webhook 或 RBAC 控制誰可以自動批准。</p>
<div class="note info"><p>自動化管理證書簽名：</p>
<ol>
<li>Create CertificateSigningRequest Object</li>
<li>Reviewing Requests</li>
<li>Approve Requests</li>
<li>Share Certs to Users</li>
</ol>
</div>

<h3 id="1-建立私鑰與-CSR-檔案"><a href="#1-建立私鑰與-CSR-檔案" class="headerlink" title="1. 建立私鑰與 CSR 檔案"></a>1. 建立私鑰與 CSR 檔案</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 產生私鑰</span></span><br><span class="line">openssl genrsa -out jane.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># 產生 CSR 憑證請求，這裡指定 CN 名稱為 jane</span></span><br><span class="line">openssl req -new -key jane.key -subj <span class="string">&quot;/CN=jane&quot;</span> -out jane.csr</span><br></pre></td></tr></table></figure>

<h3 id="2-將-CSR-編碼後建立-K8s-CSR-資源"><a href="#2-將-CSR-編碼後建立-K8s-CSR-資源" class="headerlink" title="2. 將 CSR 編碼後建立 K8s CSR 資源"></a>2. 將 CSR 編碼後建立 K8s CSR 資源</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Encode: base64 編碼 jane.csr</span></span><br><span class="line"><span class="built_in">cat</span> jane.csr | <span class="built_in">base64</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>建立 CSR 資源時，需將上面 Encode 後的 base64 結果貼入 spec.request 欄位。(jane-csr.yaml)<br><code>tr -d &#39;\n&#39;</code> 是移除換行符號，確保貼進 YAML 的 spec.request 欄位是一行文字。</p>
</blockquote>
<p>範例 YAML：jane-csr.yaml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">certificates.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">CertificateSigningRequest</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">jane</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">request:</span> [<span class="string">貼上</span> <span class="string">base64</span> <span class="string">編碼後的</span> <span class="string">CSR</span>]</span><br><span class="line">  <span class="attr">signerName:</span> <span class="string">kubernetes.io/kube-apiserver-client</span></span><br><span class="line">  <span class="attr">usages:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="string">client</span> <span class="string">auth</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f jane-csr.yaml</span><br></pre></td></tr></table></figure>

<h3 id="3-審核與批准-CSR-請求"><a href="#3-審核與批准-CSR-請求" class="headerlink" title="3. 審核與批准 CSR 請求"></a>3. 審核與批准 CSR 請求</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看所有 CSR</span></span><br><span class="line">kubectl get csr</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 jane 的詳細內容</span></span><br><span class="line">kubectl get csr jane -o yaml</span><br></pre></td></tr></table></figure>

<p>若確認無誤後，執行批准指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl certificate approve jane</span><br></pre></td></tr></table></figure>
<p>若需要拒絕請求，可用：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl certificate deny jane</span><br></pre></td></tr></table></figure>

<h3 id="4-取得簽署後的憑證"><a href="#4-取得簽署後的憑證" class="headerlink" title="4. 取得簽署後的憑證"></a>4. 取得簽署後的憑證</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 將憑證存出來</span></span><br><span class="line">kubectl get csr jane -o jsonpath=<span class="string">&#x27;&#123;.status.certificate&#125;&#x27;</span> | <span class="built_in">base64</span> --decode &gt; jane.crt</span><br><span class="line"><span class="comment"># jane.crt 是由 Kubernetes CA 簽發的 PEM 格式用戶憑證</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>匯出的 jane.crt 為 PEM 編碼（base64 格式）之 X.509 憑證，可直接用於 kubeconfig 或 openssl 驗證。</p>
</blockquote>
<p>現在你就擁有：</p>
<ul>
<li>jane.key（私鑰）</li>
<li>jane.crt（由 K8s 簽署的用戶端憑證）</li>
</ul>
<hr>
<h1 id="Certificates-API-與控制器說明"><a href="#Certificates-API-與控制器說明" class="headerlink" title="Certificates API 與控制器說明"></a>Certificates API 與控制器說明</h1><p>在 Kubernetes controlplane 中，<code>kube-controller-manager</code> 是負責執行多種控制器（controller）的核心元件，其中也包含與憑證相關的操作流程。</p>
<p>當簽署 CSR（CertificateSigningRequest）時，Kube Controller Manager 會使用設定好的 CA 憑證（root certificate）與私鑰（private key）對 CSR 進行簽章。</p>
<p>這些憑證簽發流程，實際上是由 Controller Manager 內部的兩個控制器負責處理：</p>
<table>
<thead>
<tr>
<th>Controller Name</th>
<th>功能說明</th>
</tr>
</thead>
<tbody><tr>
<td><code>csr-approving</code> controller</td>
<td>決定是否核准 CSR</td>
</tr>
<tr>
<td><code>csr-signing</code> controller</td>
<td>使用 CA 憑證與私鑰簽署 CSR</td>
</tr>
</tbody></table>
<h2 id="檢查-Controller-Manager-憑證簽署參數"><a href="#檢查-Controller-Manager-憑證簽署參數" class="headerlink" title="檢查 Controller Manager 憑證簽署參數"></a>檢查 Controller Manager 憑證簽署參數</h2><p>這些控制器會使用 Controller Manager 設定檔中指定的 CA 憑證與私鑰：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/kubernetes/manifests/kube-controller-manager.yaml</span><br></pre></td></tr></table></figure>

<p>請確認以下參數存在（K8s 使用此 CA 進行簽名）：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">--cluster-signing-cert-file=/etc/kubernetes/pki/ca.crt</span></span><br><span class="line"><span class="string">--cluster-signing-key-file=/etc/kubernetes/pki/ca.key</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="CSR-編碼與解碼小技巧"><a href="#CSR-編碼與解碼小技巧" class="headerlink" title="CSR 編碼與解碼小技巧"></a>CSR 編碼與解碼小技巧</h1><h2 id="Encode"><a href="#Encode" class="headerlink" title="Encode"></a>Encode</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> jane.csr | <span class="built_in">base64</span> | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure>

<h2 id="Decode"><a href="#Decode" class="headerlink" title="Decode"></a>Decode</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;[Encode後的結果_base64編碼]&quot;</span> | <span class="built_in">base64</span> --decode</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="小結：K8s-CSR-流程重點"><a href="#小結：K8s-CSR-流程重點" class="headerlink" title="小結：K8s CSR 流程重點"></a>小結：K8s CSR 流程重點</h1><ol>
<li>建立私鑰與 CSR（含 CN 身份）</li>
<li>將 CSR base64 編碼後建立 Kubernetes 資源</li>
<li>管理員審核並批准（可自動或手動）</li>
<li>匯出簽署憑證，供用戶端連線使用</li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>CA</tag>
        <tag>Certificate</tag>
        <tag>CSR</tag>
        <tag>kube-controller-manager</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s | Security - 1</title>
    <url>/2025/06/21/K8s-Advanced/K8s-Security-1/</url>
    <content><![CDATA[<h1 id="K8s-Security-Primitives"><a href="#K8s-Security-Primitives" class="headerlink" title="K8s Security Primitives"></a>K8s Security Primitives</h1><h2 id="Secure-K8s"><a href="#Secure-K8s" class="headerlink" title="Secure K8s"></a>Secure K8s</h2><h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><div class="note info"><p><mark>What is kube-apiserver?</mark><br>kube-apiserver 是 Kubernetes 控制平面的核心組件之一，扮演整個叢集的大腦與出入口。<br>它提供一個 HTTP REST API，所有的內部元件（如 kubelet、controller-manager）與外部工具（如 kubectl、CI&#x2F;CD pipeline）都透過它來與 Kubernetes 互動。</p>
<p><mark>🔐 常見安全設定</mark></p>
<table>
<thead>
<tr>
<th>類型</th>
<th>範例設定方式</th>
</tr>
</thead>
<tbody><tr>
<td>認證</td>
<td>Token、憑證、HTTP Basic、OIDC、Webhook</td>
</tr>
<tr>
<td>授權</td>
<td>RBAC、ABAC、Webhook</td>
</tr>
<tr>
<td>傳輸加密</td>
<td>HTTPS、TLS 憑證</td>
</tr>
<tr>
<td>請求限制</td>
<td>Audit Policy、Rate Limiting、Webhook 驗證器</td>
</tr>
</tbody></table>
<br>

<p><mark>✅ 小提醒</mark></p>
<ul>
<li>kube-apiserver 是無狀態的（stateless），可橫向擴展以提高高可用性。</li>
<li>狀態都存放在 etcd。</li>
<li>若 apiserver 掛掉，只要 etcd 還在，叢集狀態不會遺失。</li>
</ul>
</div>

<p>Authentication (驗證): Who can access?</p>
<ol>
<li>Files – Username and Passwords</li>
<li>Files – Username and Tokens</li>
<li>Certificates</li>
<li>External Authentication providers - LDAP</li>
<li>Service Accounts</li>
</ol>
<p>Authorization (授權): What can they do?</p>
<ol>
<li>RBAC Authorization</li>
<li>ABAC Authorization</li>
<li>Node Authorization</li>
<li>Webhook Mode</li>
</ol>
<h2 id="TLS-Certificates"><a href="#TLS-Certificates" class="headerlink" title="TLS Certificates"></a>TLS Certificates</h2><p>Kube ApiServer (Master)</p>
<ul>
<li>ETCD CLUSTER (Master)</li>
<li>Kube Scheduler (Master)</li>
<li>Kube Controller Manager (Master)</li>
<li>Kubelet (Worker Nodes)</li>
<li>Kube Proxy (Worker Nodes)</li>
</ul>
<h2 id="Network-Policies"><a href="#Network-Policies" class="headerlink" title="Network Policies"></a>Network Policies</h2><hr>
<h1 id="Authentication"><a href="#Authentication" class="headerlink" title="Authentication"></a>Authentication</h1><p>Kubernetes <code>本身</code> 的確 <code>「不主動管理帳號（account）」</code>，但它提供帳號的概念與機制，讓外部系統或管理者進行 <code>身份驗證與授權整合</code>。</p>
<p>✅ 結論：K8s 不管理帳號，但提供「授權架構」</p>
<table>
<thead>
<tr>
<th>功能面向</th>
<th>Kubernetes 做的事</th>
</tr>
</thead>
<tbody><tr>
<td>帳號管理</td>
<td>❌ 不管理 User 帳號，需依賴外部系統驗證</td>
</tr>
<tr>
<td>認證機制</td>
<td>✅ 提供多種身份驗證接口</td>
</tr>
<tr>
<td>授權（RBAC）</td>
<td>✅ 控制誰能對什麼資源做什麼操作</td>
</tr>
<tr>
<td>Service Account</td>
<td>✅ 自動建立與管理，供 Pod 使用</td>
</tr>
</tbody></table>
<h2 id="Accounts"><a href="#Accounts" class="headerlink" title="Accounts"></a>Accounts</h2><p>User (使用者帳號) 會先經過 kube-apiserver (Authenticate User) 驗證後，才 Process request。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Admins      --- kubectl                              -</span><br><span class="line">                                                      |---&gt; kube-apiserver ---&gt; Process request</span><br><span class="line">Developers  --- curl https://kube-server-ip:6443/    -</span><br></pre></td></tr></table></figure>

<h3 id="Authentication-流程圖"><a href="#Authentication-流程圖" class="headerlink" title="Authentication 流程圖"></a>Authentication 流程圖</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[kubectl]      [curl / script]    [Pod / Controller]</span><br><span class="line">   │                 │                       │</span><br><span class="line">   └──────┐     ┌────┴────────┐       ┌──────┘</span><br><span class="line">          ▼     ▼             ▼       ▼</span><br><span class="line">             [ kube-apiserver ]</span><br><span class="line">                     │</span><br><span class="line">            [ AuthN → AuthZ → Admission → etcd ]</span><br></pre></td></tr></table></figure>

<p>Accounts 類型比較</p>
<table>
<thead>
<tr>
<th>類型</th>
<th>說明</th>
<th>Kubernetes 是否自動管理？</th>
</tr>
</thead>
<tbody><tr>
<td><strong>User Account（使用者帳號）</strong></td>
<td>給人類使用者（例如 Admin、DevOps）</td>
<td>❌ 不會管理，也不儲存在 K8s 中</td>
</tr>
<tr>
<td><strong>Service Account（服務帳號）</strong></td>
<td>給 Pod 或內部控制器使用</td>
<td>✅ 由 K8s 管理與建立</td>
</tr>
</tbody></table>
<h3 id="User-使用者帳號"><a href="#User-使用者帳號" class="headerlink" title="User (使用者帳號)"></a>User (使用者帳號)</h3><blockquote>
<p>例如：Admins, Developers</p>
</blockquote>
<ul>
<li>K8s <code>不會建立、儲存或驗證</code> User 帳號。</li>
<li>常見身份驗證來源（通常透過外部系統提供。需由管理者或 DevOps 架設）：<ul>
<li>X.509 憑證（最常見，kubectl 預設方式）</li>
<li>OIDC &#x3D; OpenID Connect（例如與 Google、GitHub、Keycloak 整合）</li>
<li>LDAP &#x2F; Active Directory (AD)</li>
<li>Webhook Token Auth（自定 API）</li>
</ul>
</li>
<li>雖然身份驗證交由外部處理，K8s 仍可用 RBAC 對這些使用者進行授權（例如管控這個 user 可否 get pod）。</li>
</ul>
<h3 id="Service-Accounts-服務帳號"><a href="#Service-Accounts-服務帳號" class="headerlink" title="Service Accounts (服務帳號)"></a>Service Accounts (服務帳號)</h3><blockquote>
<p>例如：CI&#x2F;CD Bots</p>
</blockquote>
<ul>
<li>K8s 每個 namespace 會預設建立一個名為 <code>default</code> 的 service account (SA)。</li>
<li>若 Pod 未指定 SA，會自動綁定 <code>default</code>。</li>
<li>Pod 會透過 SA 的 Token Secret 自動掛載存取 kube-apiserver。（例如：與 etcd 同步、看其他資源）</li>
<li>可使用 RBAC 控制其存取權限。</li>
<li>常用指令：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立 ServiceAccount</span></span><br><span class="line">kubectl create serviceaccount &lt;sa_name&gt; -n &lt;namespace&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查詢</span></span><br><span class="line">kubectl get serviceaccounts -n &lt;namespace&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="kube-apiserver-的-Auth-Mechanisms"><a href="#kube-apiserver-的-Auth-Mechanisms" class="headerlink" title="kube-apiserver 的 Auth Mechanisms"></a>kube-apiserver 的 Auth Mechanisms</h2><table>
<thead>
<tr>
<th>類型</th>
<th>說明</th>
<th>建議使用？</th>
</tr>
</thead>
<tbody><tr>
<td>Static Password File</td>
<td>使用 CSV 格式帳號密碼</td>
<td>🚫 不建議（不安全、不易擴展）</td>
</tr>
<tr>
<td>Static Token File</td>
<td>使用 Token 存放在檔案中</td>
<td>🚫 不建議（實驗、測試用途）</td>
</tr>
<tr>
<td>X.509 憑證</td>
<td>使用 client cert 登入 API（kubectl 預設）</td>
<td>✅ 建議（成熟且穩定）</td>
</tr>
<tr>
<td>OIDC（OpenID Connect）</td>
<td>OAuth2 相容身份系統（如 Google）</td>
<td>✅ 建議（支援 SSO）</td>
</tr>
<tr>
<td>Webhook Token Auth</td>
<td>將請求導向自定 API 做身份驗證</td>
<td>✅ 建議（彈性高）</td>
</tr>
</tbody></table>
<details class="note default"><summary><p>補充說明：Static File Auth</p>
</summary>
<p>在 kubeadm 安裝環境中，如果使用 static token&#x2F;password 認證方式，需透過 Volume 將檔案掛載進 kube-apiserver。<br>⚠️  生產環境不建議使用 static file authentication，請優先使用憑證或 OIDC。</p>

</details>

<hr>
<h1 id="TLS-Basics-PRE-REQ"><a href="#TLS-Basics-PRE-REQ" class="headerlink" title="TLS Basics (PRE-REQ)"></a>TLS Basics (PRE-REQ)</h1><h2 id="TLS-Certificates-1"><a href="#TLS-Certificates-1" class="headerlink" title="TLS Certificates"></a>TLS Certificates</h2><p>TLS（Transport Layer Security）是用來加密兩端通訊的重要技術 (網路通訊加密協定)，常見於 HTTPS、Kubernetes、SSH 等場景。<br>TLS 憑證基於 <code>公開金鑰加密（Public Key Cryptography）</code> 和 <code>PKI 架構</code>。</p>
<h3 id="Symmetric-Encryption（對稱式加密）"><a href="#Symmetric-Encryption（對稱式加密）" class="headerlink" title="Symmetric Encryption（對稱式加密）"></a>Symmetric Encryption（對稱式加密）</h3><ul>
<li>雙方共用 <code>同一把密鑰</code> 來加解密。</li>
<li>加密快速，但 <code>密鑰分發困難、不安全</code> (密鑰交換困難)。</li>
<li>適合資料傳輸，但不適合建立安全連線。</li>
</ul>
<h3 id="Asymmetric-Encryption（非對稱式加密）"><a href="#Asymmetric-Encryption（非對稱式加密）" class="headerlink" title="Asymmetric Encryption（非對稱式加密）"></a>Asymmetric Encryption（非對稱式加密）</h3><ul>
<li>一對金鑰：<code>Private Key（私鑰）</code> 與 <code>Public Key（公開鑰 / 公開鎖, aka. Public Lock）</code></li>
<li>加密與解密由不同金鑰完成：<ul>
<li>公鑰加密 → 私鑰解密</li>
<li>私鑰簽名 → 公鑰驗證</li>
</ul>
</li>
<li>✅ 適用於建立安全連線與身分驗證<br><mark>Public Key &#x3D; 公開鎖，只有私鑰才能解開它。</mark></li>
</ul>
<h3 id="金鑰與憑證範例"><a href="#金鑰與憑證範例" class="headerlink" title="金鑰與憑證範例"></a>金鑰與憑證範例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 產生 SSH 金鑰對（與 TLS 相似邏輯）</span></span><br><span class="line">ssh-keygen</span><br><span class="line"></span><br><span class="line"><span class="comment"># 預設產出兩個檔案：</span></span><br><span class="line"><span class="comment"># 1. 私鑰 (Private Key): ~/.ssh/id_rsa    → 對應 TLS 中的 *.key 或 *-key.pem</span></span><br><span class="line"><span class="comment"># 2. 公鑰 (Public Key): ~/.ssh/id_rsa.pub → 對應 TLS 中的 *.crt 或 *.pem</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 登入使用 SSH 私鑰</span></span><br><span class="line">ssh -i id_rsa user1@server1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看伺服器上允許的公鑰</span></span><br><span class="line"><span class="built_in">cat</span> ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>

<h3 id="Certificate-Authority-CA"><a href="#Certificate-Authority-CA" class="headerlink" title="Certificate Authority (CA)"></a>Certificate Authority (CA)</h3><ul>
<li>CA 是受信任的憑證簽發單位，用來簽署憑證以證明身份真實性。</li>
<li>憑證中包含：<ul>
<li>公鑰</li>
<li>實體資訊（如：CN、OU、DNS name）</li>
<li>CA 的簽名</li>
</ul>
</li>
<li>TLS 憑證是由 CA 簽發（或自簽）後，附上「公鑰 + 身份資訊」的檔案。</li>
<li>常見格式：.crt、.pem</li>
</ul>
<h3 id="Public-Key-Infrastructure-PKI"><a href="#Public-Key-Infrastructure-PKI" class="headerlink" title="Public Key Infrastructure (PKI)"></a>Public Key Infrastructure (PKI)</h3><blockquote>
<p>建立、簽署與管理憑證(公私鑰 + 憑證)的信任架構</p>
</blockquote>
<p>PKI 架構包含：</p>
<ul>
<li>憑證簽署請求（CSR）：由持有私鑰者發出，請求 CA 簽名</li>
<li>CA 簽發憑證：根據 CSR 回傳正式憑證</li>
<li>憑證鏈（Chain of Trust）：Root Certificates、Server Certificates、Client Certificates 串接</li>
<li>憑證有效性檢查（OCSP、CRL）：憑證撤銷機制</li>
</ul>
<h3 id="TLS-運作核心概念（整合）"><a href="#TLS-運作核心概念（整合）" class="headerlink" title="TLS 運作核心概念（整合）"></a>TLS 運作核心概念（整合）</h3><table>
<thead>
<tr>
<th>元件</th>
<th>內容</th>
</tr>
</thead>
<tbody><tr>
<td>Private Key</td>
<td>自己保管，負責解密資料或產生數位簽章</td>
</tr>
<tr>
<td>Public Key</td>
<td>發給對方，讓對方對資料加密或驗證簽章</td>
</tr>
<tr>
<td>Certificate（憑證）</td>
<td>公鑰 + 身份資訊（如 CN、OU），經 CA 簽章</td>
</tr>
<tr>
<td>TLS 通訊</td>
<td>初始階段使用 <code>非對稱加密</code> 交換對稱密鑰 → 後續資料交換使用 <code>對稱加密</code></td>
</tr>
</tbody></table>
<p>Server Certificates for Servers</p>
<ul>
<li>kube-api server</li>
<li>etcd server</li>
<li>kubelet server</li>
</ul>
<p>Client Certificates for Clients</p>
<ul>
<li>admin</li>
<li>kube-scheduler</li>
<li>kube-controller-manager</li>
<li>kube-proxy</li>
</ul>
<h3 id="Generate-Certificates"><a href="#Generate-Certificates" class="headerlink" title="Generate Certificates"></a>Generate Certificates</h3><p>Tools:</p>
<ol>
<li>EASYRSA</li>
<li>OPENSSL</li>
<li>CFSSL</li>
</ol>
<p>Certificate Authority (CA)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Generate Keys</span></span><br><span class="line">openssl genrsa -out ca.key 2048</span><br><span class="line"></span><br><span class="line"><span class="comment"># Certificate Signing Request</span></span><br><span class="line">openssl req -new -key ca.key -subj <span class="string">&quot;/CN=KUBERNETES-CA&quot;</span> -out ca.csr</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sign Certificates</span></span><br><span class="line">openssl x509 -req -<span class="keyword">in</span> ca.csr -signkey ca.key -out ca.crt</span><br></pre></td></tr></table></figure>


<p>View Certificate Details</p>
<p>Certificate Workflow &amp; API</p>
<p>KUBECONFIG</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>K8s Security Primitives</tag>
        <tag>Authentication</tag>
        <tag>TLS Certificates for Cluster Components</tag>
        <tag>Secure Persistent Key Value Store</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Security | KubeConfig</title>
    <url>/2025/07/08/K8s-Advanced/K8s-Security-KubeConfig/</url>
    <content><![CDATA[<h1 id="KubeConfig-概述"><a href="#KubeConfig-概述" class="headerlink" title="KubeConfig 概述"></a>KubeConfig 概述</h1><p>KubeConfig 是 K8s 客戶端（kubectl）與 API Server 通訊所依賴的設定檔。它包含：</p>
<ul>
<li>使用者身份驗證資訊（client certificate &#x2F; token）</li>
<li>API Server 的連線位置與憑證</li>
<li>多環境 context 的定義與切換</li>
</ul>
<h2 id="使用憑證直接存取-API-Server"><a href="#使用憑證直接存取-API-Server" class="headerlink" title="使用憑證直接存取 API Server"></a>使用憑證直接存取 API Server</h2><p>不透過 kubeconfig，可使用 <code>curl</code> 或 <code>kubectl</code> 明確指定憑證：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://my-kube-playground:6443/api/v1/pods \</span><br><span class="line">  --key admin.key \</span><br><span class="line">  --cert admin.crt \</span><br><span class="line">  --cacert ca.crt</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods \</span><br><span class="line">  --server my-kube-playground:6443 \</span><br><span class="line">  --client-key admin.key \</span><br><span class="line">  --client-certificate admin.crt \</span><br><span class="line">  --certificate-authority ca.crt</span><br></pre></td></tr></table></figure>

<h2 id="使用-kubeconfig-存取集群"><a href="#使用-kubeconfig-存取集群" class="headerlink" title="使用 kubeconfig 存取集群"></a>使用 kubeconfig 存取集群</h2><p>預設情況下，kubectl 會從以下路徑載入設定：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$HOME/.kube/config</span><br></pre></td></tr></table></figure>

<p>你也可以使用 –kubeconfig 指定其他配置檔：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods --kubeconfig=my-cluster-config.yaml</span><br><span class="line">kubectl get pods   <span class="comment"># 預設使用 $HOME/.kube/config</span></span><br></pre></td></tr></table></figure>

<img src="/2025/07/08/K8s-Advanced/K8s-Security-KubeConfig/KubeConfig_1.webp" class="">

<hr>
<h1 id="KubeConfig-結構說明"><a href="#KubeConfig-結構說明" class="headerlink" title="KubeConfig 結構說明"></a>KubeConfig 結構說明</h1><img src="/2025/07/08/K8s-Advanced/K8s-Security-KubeConfig/KubeConfig_2.webp" class="">
<img src="/2025/07/08/K8s-Advanced/K8s-Security-KubeConfig/KubeConfig_3.webp" class="">

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Config</span></span><br><span class="line"></span><br><span class="line"><span class="attr">current-context:</span> <span class="string">dev-user@google</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-kube-playground</span></span><br><span class="line">  <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority:</span> <span class="string">/etc/kubernetes/pki/ca.crt</span></span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://my-kube-playground:6443</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> [<span class="string">another-cluster</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-kube-admin@my-kube-playground</span></span><br><span class="line">  <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">my-kube-playground</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">my-kube-admin</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> [<span class="string">another-context</span>]</span><br><span class="line"></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-kube-admin</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate:</span> <span class="string">/etc/kubernetes/pki/users/admin.crt</span></span><br><span class="line">    <span class="attr">client-key:</span> <span class="string">/etc/kubernetes/pki/users/admin.key</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> [<span class="string">another-user</span>]</span><br></pre></td></tr></table></figure>

<h2 id="YAML-中的-current-context"><a href="#YAML-中的-current-context" class="headerlink" title="YAML 中的 current-context"></a>YAML 中的 current-context</h2><table>
<thead>
<tr>
<th>問題</th>
<th>解答</th>
</tr>
</thead>
<tbody><tr>
<td><code>current-context</code><br>可以放多個嗎？</td>
<td>❌ 不行，current-context 只能有一個。代表當前預設使用的 context。</td>
</tr>
<tr>
<td><code>current-context</code><br>不放會怎樣？</td>
<td>預設情況下 <code>kubectl</code> 會無法知道要使用哪一個 context，執行會出錯或需手動指定 <code>--context</code>。</td>
</tr>
</tbody></table>
<p>若要切換 <code>current-context</code>，請使用以下指令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl config use-context prod-user@production</span><br><span class="line"></span><br><span class="line">kubectl config -h</span><br></pre></td></tr></table></figure>

<h2 id="Context-與-Namespace-綁定"><a href="#Context-與-Namespace-綁定" class="headerlink" title="Context 與 Namespace 綁定"></a>Context 與 Namespace 綁定</h2><img src="/2025/07/08/K8s-Advanced/K8s-Security-KubeConfig/KubeConfig_4.webp" class="">

<p>每個 context 可以綁定不同的命名空間，達到同一個 cluster 上的多租戶管理：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">contexts:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-kube-admin@my-kube-playground</span></span><br><span class="line">  <span class="attr">context:</span></span><br><span class="line">    <span class="attr">cluster:</span> <span class="string">my-kube-playground</span></span><br><span class="line">    <span class="attr">user:</span> <span class="string">my-kube-admin</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">finance</span>  <span class="comment"># 預設 namespace</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ...</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>若 context 中未設定 namespace，則預設為 default。<br>在 kubeconfig YAML 結構中，<mark>namespace 只能出現在 contexts: 裡的 context 子欄位中</mark>。</p>
</blockquote>
<div class="note info"><p><strong>Namespace 優先權說明</strong>：<br>若同時在 <code>context</code> 設定與 CLI 中指定 namespace，kubectl 會<strong>優先採用 CLI 的 <code>--namespace</code></strong> 參數。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pods --namespace=dev</span><br><span class="line"><span class="comment"># 覆蓋 kubeconfig 裡 context 的 namespace 設定</span></span><br></pre></td></tr></table></figure></div>

<h2 id="支援-base64-編碼憑證與憑證內嵌"><a href="#支援-base64-編碼憑證與憑證內嵌" class="headerlink" title="支援 base64 編碼憑證與憑證內嵌"></a>支援 base64 編碼憑證與憑證內嵌</h2><p>你可以使用 certificate-authority-data 或 client-certificate-data 直接嵌入 base64 編碼的內容：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ...</span></span><br><span class="line"></span><br><span class="line"><span class="attr">clusters:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">production</span></span><br><span class="line">  <span class="attr">cluster:</span></span><br><span class="line">    <span class="attr">certificate-authority-data:</span> [<span class="string">base64</span> <span class="string">編碼的</span> <span class="string">ca.crt</span>]</span><br><span class="line">    <span class="attr">server:</span> <span class="string">https://my-kube-playground:6443</span></span><br><span class="line"></span><br><span class="line"><span class="attr">users:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">name:</span> <span class="string">my-kube-admin</span></span><br><span class="line">  <span class="attr">user:</span></span><br><span class="line">    <span class="attr">client-certificate-data:</span> [<span class="string">base64</span> <span class="string">編碼的</span> <span class="string">admin.crt</span>]</span><br><span class="line">    <span class="attr">client-key-data:</span> [<span class="string">base64</span> <span class="string">編碼的</span> <span class="string">admin.key</span>]</span><br></pre></td></tr></table></figure>

<p>產出 base64 編碼方式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">base64</span> -w 0 ca.crt       <span class="comment"># -w 0 表示不換行</span></span><br><span class="line"><span class="built_in">base64</span> -w 0 admin.crt</span><br><span class="line"><span class="built_in">base64</span> -w 0 admin.key</span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="built_in">base64</span> ca.crt | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="built_in">base64</span> admin.crt | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="built_in">base64</span> admin.key | <span class="built_in">tr</span> -d <span class="string">&#x27;\n&#x27;</span></span><br></pre></td></tr></table></figure>



<h1 id="常用指令彙總"><a href="#常用指令彙總" class="headerlink" title="常用指令彙總"></a>常用指令彙總</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看目前的 KubeConfig 的設定內容</span></span><br><span class="line">kubectl config view</span><br><span class="line">kubectl config view --kubeconfig=my-cluster-config.yaml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用不同的 config 檔</span></span><br><span class="line">kubectl --kubeconfig=/path/to/my-cluster-config.yaml get pods</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切換 context</span></span><br><span class="line">kubectl config use-context dev-user@google</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出所有 context</span></span><br><span class="line">kubectl config get-contexts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 抓 context 名稱</span></span><br><span class="line">kubectl config get-contexts -o name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 設定預設 namespace</span></span><br><span class="line">kubectl config set-context my-context --namespace=finance</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立新的 context</span></span><br><span class="line">kubectl config set-context dev@dev-cluster \</span><br><span class="line">  --cluster=dev-cluster \</span><br><span class="line">  --user=dev-user \</span><br><span class="line">  --namespace=dev-namespace</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立新的使用者（搭配 token 或 cert）</span></span><br><span class="line">kubectl config set-credentials dev-user \</span><br><span class="line">  --client-certificate=./dev-user.crt \</span><br><span class="line">  --client-key=./dev-user.key</span><br><span class="line"></span><br><span class="line"><span class="comment"># 建立新的 cluster 設定</span></span><br><span class="line">kubectl config set-cluster dev-cluster \</span><br><span class="line">  --server=https://dev.example.com:6443 \</span><br><span class="line">  --certificate-authority=./ca.crt</span><br></pre></td></tr></table></figure>

<h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><ul>
<li>kubeconfig 支援多個使用者、多個叢集、多組 context</li>
<li>current-context 只能存在一個，是預設操作對象</li>
<li>context 可綁定 cluster、user、namespace</li>
<li>憑證可以使用路徑或 base64 方式設定</li>
<li>使用 kubectl config 管理多環境操作非常方便</li>
<li>context 可指定預設 namespace，亦可在 CLI 使用 <code>--namespace</code> 臨時覆蓋。</li>
</ul>
<hr>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ol>
<li><a href="https://yuminlee2.medium.com/kubernetes-kubeconfig-file-4aabe3b04ade">Kubernetes: Kubeconfig File</a></li>
</ol>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubeconfig</tag>
        <tag>client-certificate</tag>
        <tag>kubectl</tag>
        <tag>context</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Security | Network Policy</title>
    <url>/2025/07/11/K8s-Advanced/K8s-Security-Network-Policy/</url>
    <content><![CDATA[<h1 id="Traffic"><a href="#Traffic" class="headerlink" title="Traffic"></a>Traffic</h1><h2 id="Pod-Networking-行為（預設）"><a href="#Pod-Networking-行為（預設）" class="headerlink" title="Pod Networking 行為（預設）"></a>Pod Networking 行為（預設）</h2><ul>
<li><mark>K8s 預設允許 <strong>所有 Pod 之間互相通訊</strong>，無論是否跨 Node</mark></li>
<li>一旦某個 Pod 被任一 <code>NetworkPolicy</code> 匹配到，其網路行為將進入預設拒絕模式（deny all not explicitly allowed）<ul>
<li>進入「封閉式網路模型」，<strong>未被允許的流量將預設被封鎖</strong>（deny by default）。</li>
</ul>
</li>
<li>其他未匹配到的 Pod 則仍然是全開放。</li>
<li>若未設定 <code>NetworkPolicy</code>，等同於「全開放」。</li>
</ul>
<table>
<thead>
<tr>
<th>條件</th>
<th>網路行為</th>
</tr>
</thead>
<tbody><tr>
<td>沒有任何 NetworkPolicy</td>
<td>所有 Pod 皆可互通</td>
</tr>
<tr>
<td>只對某些 Pod 設定 NetworkPolicy</td>
<td>該些 Pod 進入封閉模式，其他 Pod 照常互通</td>
</tr>
</tbody></table>
<h2 id="Ingress-vs-Egress"><a href="#Ingress-vs-Egress" class="headerlink" title="Ingress vs Egress"></a>Ingress vs Egress</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">policyTypes:</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">Egress</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>類型</th>
<th>控制方向</th>
<th>說明範例</th>
<th>常見用途</th>
</tr>
</thead>
<tbody><tr>
<td>Ingress</td>
<td>進入流量（控制誰可以進來）</td>
<td>控制哪些 Pod&#x2F;來源可以連進來</td>
<td>限制資料庫只能接受來自 API 的流量</td>
</tr>
<tr>
<td>Egress</td>
<td>離開流量（控制能連誰）</td>
<td>控制該 Pod 可向哪些目的地&#x2F;Port 發出連線</td>
<td>限制 Pod 只能對內部服務或特定 IP 發出連線</td>
</tr>
</tbody></table>
<blockquote>
<p>✅ NetworkPolicy 是從 <strong>Pod 角度出發</strong>，決定「這個 Pod <strong>能被誰連進來</strong>」（Ingress）與「<strong>它能對誰發出連線</strong>」（Egress）。</p>
</blockquote>
<hr>
<h1 id="🔒-Network-Security"><a href="#🔒-Network-Security" class="headerlink" title="🔒 Network Security"></a>🔒 Network Security</h1><h2 id="實作：限制-API-Pod-只能連接-DB"><a href="#實作：限制-API-Pod-只能連接-DB" class="headerlink" title="實作：限制 API Pod 只能連接 DB"></a>實作：限制 API Pod 只能連接 DB</h2><div class="note info"><p>Q：如果不希望 web pod 能直接溝通 db pod，該怎麼做？<br>A：db pod 設定一個 NetworkPolicy，只允許 API Pod 發送 3306 port 連線給 DB Pod。</p>
<ul>
<li>Allow Ingress Traffic from API Pod on port 3306</li>
<li>Egress 不設定（預設可以互通）</li>
</ul>
<p>常見誤區</p>
<ul>
<li>許多人會誤以為沒定義 Egress Policy 就無法連外，其實 <strong>預設還是能連</strong>。</li>
<li>只有當某個 <code>policyType: Egress</code> 存在時，Egress 才會被限制。</li>
</ul>
<p>Policy 與 Service 沒有直接關聯的提醒</p>
<ul>
<li>NetworkPolicy 是作用在 Pod 層，而非 Service；即使 Service 存在，若對應的 Pod 被封鎖，連線仍會失敗。</li>
</ul>
</div>

<h3 id="db-policy-yaml"><a href="#db-policy-yaml" class="headerlink" title="db-policy.yaml"></a>db-policy.yaml</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">db-policy</span></span><br><span class="line">  <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span>  <span class="comment"># 強調 Label 的 match 條件是「完全符合」</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">db</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Ingress</span></span><br><span class="line">  <span class="attr">ingress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">        <span class="attr">matchLabels:</span></span><br><span class="line">          <span class="attr">role:</span> <span class="string">api</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">3306</span></span><br></pre></td></tr></table></figure>

<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">podSelector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span>  <span class="comment"># 只會匹配 role=db 的 Pod</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">db</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>所有 <code>role=db</code> 的 Pod（如 <code>mysql</code>）將只能接受 <code>role=api</code> 的 Pod 發送連線（且限 port 3306）；其他來源（如 <code>web</code>）都會被阻擋。</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">podSelector:</span></span><br><span class="line">  <span class="attr">matchLabels:</span>  <span class="comment"># 僅匹配同時具有 role=db 且 tier=backend 的 Pod（AND 條件）</span></span><br><span class="line">    <span class="attr">role:</span> <span class="string">db</span></span><br><span class="line">    <span class="attr">tier:</span> <span class="string">backend</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Pod 有上述兩個 label，也仍會 match 到只指定 <code>role: db</code> 的 policy。</p>
</blockquote>
<h3 id="建立-NetworkPolicy"><a href="#建立-NetworkPolicy" class="headerlink" title="建立 NetworkPolicy"></a>建立 NetworkPolicy</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl apply -f db-policy.yaml</span><br></pre></td></tr></table></figure>

<h2 id="驗證-NetworkPolicy-是否生效"><a href="#驗證-NetworkPolicy-是否生效" class="headerlink" title="驗證 NetworkPolicy 是否生效"></a>驗證 NetworkPolicy 是否生效</h2><h3 id="使用-busybox-建立測試-Pod"><a href="#使用-busybox-建立測試-Pod" class="headerlink" title="使用 busybox 建立測試 Pod"></a>使用 busybox 建立測試 Pod</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立有 nc 指令的測試 pod</span></span><br><span class="line">kubectl run testbox --<span class="built_in">rm</span> -it --image=busybox:1.28 -- /bin/sh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 nc 測試連線</span></span><br><span class="line">nc -zv db-service 3306</span><br></pre></td></tr></table></figure>

<h3 id="嘗試從-role-web-的-Pod-發送連線"><a href="#嘗試從-role-web-的-Pod-發送連線" class="headerlink" title="嘗試從 role&#x3D;web 的 Pod 發送連線"></a>嘗試從 role&#x3D;web 的 Pod 發送連線</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">telnet db-service 3306   <span class="comment"># 預期會失敗</span></span><br></pre></td></tr></table></figure>

<h3 id="從-role-api-的-Pod-嘗試連線"><a href="#從-role-api-的-Pod-嘗試連線" class="headerlink" title="從 role&#x3D;api 的 Pod 嘗試連線"></a>從 role&#x3D;api 的 Pod 嘗試連線</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> api-pod -- nc -zv db-service 3306  <span class="comment"># ✅ 預期成功</span></span><br></pre></td></tr></table></figure>

<h2 id="Egress-實作範例（選擇性補充）"><a href="#Egress-實作範例（選擇性補充）" class="headerlink" title="Egress 實作範例（選擇性補充）"></a>Egress 實作範例（選擇性補充）</h2><p>若你希望限制 Pod 不得對外部（如網際網路）連線</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">block-egress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">app:</span> <span class="string">restricted</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span> []   <span class="comment"># 空代表不允許任何目標。禁止所有 Egress</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ 要讓 Egress 有效，Kubernetes 必須搭配有支援 Egress 控制的 CNI，如 Calico、Cilium。<br>⚠️ K8s 本身不處理封包轉發，需透過 CNI 插件實現封包過濾。</p>
</blockquote>
<h1 id="常見小技巧與注意事項"><a href="#常見小技巧與注意事項" class="headerlink" title="常見小技巧與注意事項"></a>常見小技巧與注意事項</h1><ul>
<li><code>podSelector</code> 只能篩選 同 namespace 的 Pod</li>
<li>跨 namespace 的控制需搭配 <code>namespaceSelector</code><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">from:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">team:</span> <span class="string">backend</span>  <span class="comment"># 允許 team=frontend namespace 中的任意 Pod 存取 db</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>可搭配 <code>namespaceSelector + podSelector</code> 精確控制跨 namespace 流量<br>補充：Namespace Label 預設不會存在，需手動打上</p>
</blockquote>
</li>
<li>你也可以設定 IP-based 控制（如限制 Egress 到外部 IP）</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">ingress:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">podSelector:</span></span><br><span class="line">      <span class="attr">matchLabels:</span></span><br><span class="line">        <span class="attr">role:</span> <span class="string">api</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">from:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">      <span class="attr">cidr:</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">      <span class="attr">except:</span></span><br><span class="line">      <span class="bullet">-</span> <span class="number">10.0</span><span class="number">.0</span><span class="number">.5</span><span class="string">/32</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>多個 from 視為 OR，只要符合其中一條即可。</p>
</blockquote>
<h2 id="跨-Namespace-控制完整範例（結合-podSelector-namespaceSelector）"><a href="#跨-Namespace-控制完整範例（結合-podSelector-namespaceSelector）" class="headerlink" title="跨 Namespace 控制完整範例（結合 podSelector + namespaceSelector）"></a>跨 Namespace 控制完整範例（結合 podSelector + namespaceSelector）</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">from:</span></span><br><span class="line"><span class="bullet">-</span> <span class="attr">namespaceSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">team:</span> <span class="string">backend</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">api</span></span><br></pre></td></tr></table></figure>

<h2 id="幫-Namespace-打-Label"><a href="#幫-Namespace-打-Label" class="headerlink" title="幫 Namespace 打 Label"></a>幫 Namespace 打 Label</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl label namespace backend team=backend</span><br></pre></td></tr></table></figure>

<h2 id="Ingress-Egress-檢查技巧補充"><a href="#Ingress-Egress-檢查技巧補充" class="headerlink" title="Ingress&#x2F;Egress 檢查技巧補充"></a>Ingress&#x2F;Egress 檢查技巧補充</h2><p>實務與 CKA 考試中，快速排查 ingress&#x2F;egress 問題</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 驗證是否套用</span></span><br><span class="line">kubectl get networkpolicy -A</span><br><span class="line">kubectl describe networkpolicy &lt;policy-name&gt;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod -o wide</span><br></pre></td></tr></table></figure>
<blockquote>
<p>確認 Pod IP 和 Label，搭配 nc, curl 測試端點通不通。</p>
</blockquote>
<h1 id="CKA-考試怎麼考？"><a href="#CKA-考試怎麼考？" class="headerlink" title="CKA 考試怎麼考？"></a>CKA 考試怎麼考？</h1><p>CKA 常見題型如下：<br>☑️ 給你一組 Pod Label，要你限制某些 Pod 的進入流量（Ingress）<br>☑️ 配置 NetworkPolicy 讓 Pod 只能從特定來源 存取 DB<br>☑️ 查 Pod 無法連線，要你排查 <code>NetworkPolicy</code> 是否限制太嚴<br>☑️ 選擇性：限制 Pod 不得連外（Egress deny）</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Q: 讓 role=frontend 的 Pod 只能連線到 10.10.10.0/24 的某個外部 API</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">networking.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">NetworkPolicy</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">frontend-egress</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">podSelector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">role:</span> <span class="string">frontend</span></span><br><span class="line">  <span class="attr">policyTypes:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">Egress</span></span><br><span class="line">  <span class="attr">egress:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">to:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">ipBlock:</span></span><br><span class="line">        <span class="attr">cidr:</span> <span class="number">10.10</span><span class="number">.10</span><span class="number">.0</span><span class="string">/24</span></span><br><span class="line">    <span class="attr">ports:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">protocol:</span> <span class="string">TCP</span></span><br><span class="line">      <span class="attr">port:</span> <span class="number">443</span></span><br></pre></td></tr></table></figure>

<p>重點技巧：</p>
<ol>
<li>熟悉 <code>podSelector</code> 搭配 <code>matchLabels</code></li>
<li>熟練 <code>kubectl apply -f xxx.yaml</code></li>
<li>驗證技巧：<code>nc</code>, <code>telnet</code>, <code>curl</code>, <code>kubectl exec</code></li>
</ol>
<h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><ul>
<li>NetworkPolicy 是控制 Pod 間通訊的強大工具，讓你能實作微服務的最小信任原則（Zero Trust）</li>
<li>預設情況下 Pod 全開放通訊，設定任一 Policy 後會觸發預設拒絕行為</li>
<li>建議從 DB 等敏感服務開始設定防護（Ingress），逐步擴展到 Egress 控制</li>
<li>考試重視：YAML 寫法 + 驗證通訊是否成功 + Label 選擇器語法理解</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>NetworkPolicy</tag>
        <tag>Ingress</tag>
        <tag>Egress</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Security | API Groups</title>
    <url>/2025/07/08/K8s-Advanced/K8s-Security-API-Groups/</url>
    <content><![CDATA[<h1 id="Kubernetes-API-Groups-概述"><a href="#Kubernetes-API-Groups-概述" class="headerlink" title="Kubernetes API Groups 概述"></a>Kubernetes API Groups 概述</h1><p>Kubernetes API Server 對外提供的 REST API，會依據不同資源類型，劃分為不同的 API Group。</p>
<p>常見的 API 路徑如下：</p>
<table>
<thead>
<tr>
<th>路徑</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td><code>/version</code></td>
<td>顯示 API Server 的版本資訊</td>
</tr>
<tr>
<td><code>/healthz</code></td>
<td>健康檢查端點</td>
</tr>
<tr>
<td><code>/metrics</code></td>
<td>叢集監控指標，Prometheus 等可存取此路徑</td>
</tr>
<tr>
<td><code>/api</code></td>
<td>代表 <strong>Core Group (無名稱)</strong> 的資源</td>
</tr>
<tr>
<td><code>/apis</code></td>
<td>代表 <strong>Named Groups</strong>，用於延伸資源</td>
</tr>
</tbody></table>
<h1 id="API-分組詳解"><a href="#API-分組詳解" class="headerlink" title="API 分組詳解"></a>API 分組詳解</h1><h2 id="api：Core-Group（核心資源）"><a href="#api：Core-Group（核心資源）" class="headerlink" title="/api：Core Group（核心資源）"></a><code>/api</code>：Core Group（核心資源）</h2><p>屬於 Kubernetes 內建的核心資源，API Group 為空（””）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/api/v1/namespaces</span><br><span class="line">/api/v1/pods</span><br><span class="line">/api/v1/services</span><br><span class="line">/api/v1/nodes</span><br><span class="line">/api/v1/configmaps</span><br><span class="line">/api/v1/secrets</span><br><span class="line">/api/v1/persistentvolumes (PV)</span><br><span class="line">/api/v1/persistentvolumeclaims (PVC)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<img src="/2025/07/08/K8s-Advanced/K8s-Security-API-Groups/core_group.jpg" class="">

<h2 id="apis：Named-Groups（命名資源組）"><a href="#apis：Named-Groups（命名資源組）" class="headerlink" title="/apis：Named Groups（命名資源組）"></a><code>/apis</code>：Named Groups（命名資源組）</h2><p>Kubernetes 為了支援 <code>擴充性與版本管理</code>，將某些資源拆分為獨立的 Group，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/apis/apps/v1/deployments</span><br><span class="line">/apis/batch/v1/jobs</span><br><span class="line">/apis/extensions/v1beta1/ingresses</span><br><span class="line">/apis/rbac.authorization.k8s.io/v1/roles</span><br><span class="line">/apis/networking.k8s.io/v1/networkpolicies</span><br></pre></td></tr></table></figure>

<p>你可以透過下列指令列出所有可用的 API Groups：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -s https://kube-master:6443/apis \</span><br><span class="line">  --key admin.key \</span><br><span class="line">  --cert admin.crt \</span><br><span class="line">  --cacert ca.crt | grep <span class="string">&quot;name&quot;</span></span><br></pre></td></tr></table></figure>
<img src="/2025/07/08/K8s-Advanced/K8s-Security-API-Groups/named_group.jpg" class="">

<hr>
<h1 id="API-Server-測試範例"><a href="#API-Server-測試範例" class="headerlink" title="API Server 測試範例"></a>API Server 測試範例</h1><h2 id="使用-curl-直接連線-API-Server"><a href="#使用-curl-直接連線-API-Server" class="headerlink" title="使用 curl 直接連線 API Server"></a>使用 curl 直接連線 API Server</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://kube-master:6443/version \</span><br><span class="line">  --key admin.key \</span><br><span class="line">  --cert admin.crt \</span><br><span class="line">  --cacert ca.crt</span><br><span class="line"></span><br><span class="line">curl https://kube-master:6443/api/v1/pods \</span><br><span class="line">  --key admin.key \</span><br><span class="line">  --cert admin.crt \</span><br><span class="line">  --cacert ca.crt</span><br></pre></td></tr></table></figure>

<h2 id="通訊路徑整理"><a href="#通訊路徑整理" class="headerlink" title="通訊路徑整理"></a>通訊路徑整理</h2><h3 id="1-User-→-Kube-API-Server（直接）"><a href="#1-User-→-Kube-API-Server（直接）" class="headerlink" title="1. User → Kube API Server（直接）"></a>1. User → Kube API Server（直接）</h3><p>適合 debug 或憑證驗證測試：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://localhost:6443 \</span><br><span class="line">  --key admin.key \</span><br><span class="line">  --cert admin.crt \</span><br><span class="line">  --cacert ca.crt</span><br></pre></td></tr></table></figure>

<h3 id="2-User-→-kubectl-proxy-→-Kube-API-Server"><a href="#2-User-→-kubectl-proxy-→-Kube-API-Server" class="headerlink" title="2. User → kubectl proxy → Kube API Server"></a>2. User → <code>kubectl proxy</code> → Kube API Server</h3><p>若不方便操作憑證，可使用 kubectl proxy 轉發連線（本機起 proxy，無需 TLS 驗證）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl proxy</span><br><span class="line"><span class="comment"># Starting to serve on 127.0.0.1:8001</span></span><br><span class="line"></span><br><span class="line">curl http://localhost:8001/api/v1/pods</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>kubectl proxy</code> 適合開發者快速測試 K8s API，無需手動處理 TLS 憑證，不適合暴露在 production 環境。</p>
</blockquote>
<div class="note info"><p><strong>Kube Proxy ≠ Kubectl Proxy</strong></p>
<table>
<thead>
<tr>
<th>名稱</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td><code>kubectl proxy</code></td>
<td>CLI 工具，將本地 8001 port 對應到 K8s API Server，無需 TLS 驗證</td>
</tr>
<tr>
<td><code>kube-proxy</code></td>
<td>Kubernetes 元件之一，負責轉送 Service 網路流量到後端 Pod</td>
</tr>
</tbody></table>
</div>

<h2 id="常用指令"><a href="#常用指令" class="headerlink" title="常用指令"></a>常用指令</h2><h3 id="kubectl-explain"><a href="#kubectl-explain" class="headerlink" title="kubectl explain"></a>kubectl explain</h3><p>查詢資源對應的 API Group（開發與 RBAC 常用）</p>
<blockquote>
<p>快速查詢某資源對應的 API Group 與版本。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl explain deployment</span><br><span class="line"><span class="comment"># NAME:         deployment.apps</span></span><br><span class="line"><span class="comment"># API Version:  apps/v1</span></span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查詢子欄位</span></span><br><span class="line">kubectl explain deployment.spec.template.spec.containers</span><br></pre></td></tr></table></figure>

<h3 id="kubectl-api-resources"><a href="#kubectl-api-resources" class="headerlink" title="kubectl api-resources"></a>kubectl api-resources</h3><p>查看所有可用資源</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 顯示當前 kube-apiserver 所支援的資源清單及其對應 API Group。</span></span><br><span class="line">kubectl api-resources</span><br></pre></td></tr></table></figure>
<h3 id="進階技巧：查詢特定資源的-REST-API-URL"><a href="#進階技巧：查詢特定資源的-REST-API-URL" class="headerlink" title="進階技巧：查詢特定資源的 REST API URL"></a>進階技巧：查詢特定資源的 REST API URL</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw /apis/apps/v1/deployments</span><br></pre></td></tr></table></figure>
<p>或列出所有 core 資源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get --raw /api/v1</span><br></pre></td></tr></table></figure>
<blockquote>
<p>幫助使用者理解 kubectl 背後實際呼叫的 API 是哪一條路徑。</p>
</blockquote>
<hr>
<h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><ul>
<li>Kubernetes API 分為兩大類型：<ul>
<li><strong>Core Group</strong>：路徑為 <code>/api</code>，如 pods、services、nodes</li>
<li><strong>Named Groups</strong>：路徑為 <code>/apis</code>，如 deployments、roles、jobs 等</li>
</ul>
</li>
<li>API Server 介面可透過 <code>curl</code> 進行憑證驗證測試，也可透過 <code>kubectl proxy</code> 進行開發端本機 proxy 測試<ul>
<li>使用 <code>curl</code> + TLS 憑證測試 API Server 安全連線</li>
<li>使用 <code>kubectl proxy</code> 在本地啟動 HTTP 代理，可省略 TLS 憑證，適合開發階段</li>
</ul>
</li>
<li>開發與權限設定常用工具：<ul>
<li><code>kubectl explain &lt;資源&gt;</code>：查詢資源所屬的 API Group 與 version</li>
<li><code>kubectl api-resources</code>：查看所有可用的資源與所屬 Group</li>
<li><code>kubectl get --raw</code>：可查詢原始 API 路徑資料</li>
</ul>
</li>
<li>自訂資源（CRD）也會掛載於 <code>/apis</code>，屬於 Named Group</li>
<li>注意區分 <code>kubectl proxy</code> (本地 HTTP proxy) 與 <code>kube-proxy</code> (cluster service 網路元件)</li>
</ul>
<p>📌 下一步建議學習：<br>RBAC 權限控制中 <code>apiGroups</code>, <code>resources</code>, <code>verbs</code> 如何對應這些 API 分組</p>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>kubectl</tag>
        <tag>apiserver</tag>
        <tag>api-groups</tag>
        <tag>curl</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Security | Service Accounts</title>
    <url>/2025/07/10/K8s-Advanced/K8s-Security-Service-Accounts/</url>
    <content><![CDATA[<h1 id="Service-Accounts"><a href="#Service-Accounts" class="headerlink" title="Service Accounts"></a>Service Accounts</h1><h2 id="✅-背景知識與觀念"><a href="#✅-背景知識與觀念" class="headerlink" title="✅ 背景知識與觀念"></a>✅ 背景知識與觀念</h2><ul>
<li>K8s 中的每個 Pod，<strong>預設都會掛載一個 ServiceAccount</strong>（<code>default</code>），除非在 pod spec 中另行指定。</li>
<li>ServiceAccount 是 K8s 為工作負載（如 Pod）提供的身份識別方式，用來與 Kubernetes API Server 通訊。</li>
<li>可透過 <strong>RBAC</strong> 為 ServiceAccount 綁定適當的權限（<code>Role</code> &#x2F; <code>ClusterRole</code>）。</li>
<li>舊版中，<strong>ServiceAccount token 會以 Secret 形式自動掛載</strong>到 <code>/var/run/secrets/kubernetes.io/serviceaccount/token</code>，可直接透過此 token 與 API Server 溝通。</li>
</ul>
<div class="note info"><ul>
<li>Pod 與其使用的 ServiceAccount 是一對一綁定，但多個 Pod 可共用同一個 ServiceAccount。</li>
<li>舊版（v1.24 前）會自動建立一個 Secret token 並掛載；新版（v1.24+）則需透過 <code>kubectl create token</code> 明確建立。</li>
<li>Token 是以 JWT 格式存在，可用來模擬 API 認證呼叫。</li>
</ul>
</div>

<h2 id="常用操作指令"><a href="#常用操作指令" class="headerlink" title="常用操作指令"></a>常用操作指令</h2><p>查詢目前 namespace 中的所有 ServiceAccount</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get serviceaccounts</span><br></pre></td></tr></table></figure>

<p>建立 ServiceAccount</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create serviceaccount dashboard-sa</span><br></pre></td></tr></table></figure>

<p>檢視 ServiceAccount 詳細資訊（包含關聯 Secret）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl describe serviceaccount dashboard-sa</span><br></pre></td></tr></table></figure>

<p>進階驗證 token 掛載內容</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看 SA 對應的 Secret（僅限 &lt; v1.24）</span></span><br><span class="line">kubectl describe secret $(kubectl get secret | grep dashboard-sa | awk <span class="string">&#x27;&#123;print $1&#125;&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 Pod 掛載的 SA token 路徑</span></span><br><span class="line">kubectl describe pod my-kubernetes-dashboard</span><br><span class="line"></span><br><span class="line"><span class="comment"># 驗證 token 是否正確掛載</span></span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-kubernetes-dashboard -- <span class="built_in">ls</span> /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-kubernetes-dashboard -- <span class="built_in">cat</span> /var/run/secrets/kubernetes.io/serviceaccount/token</span><br><span class="line"><span class="comment"># ca.crt  namespace   token</span></span><br></pre></td></tr></table></figure>

<h2 id="常用-YAML"><a href="#常用-YAML" class="headerlink" title="常用 YAML"></a>常用 YAML</h2><h3 id="Pod-指定-ServiceAccount-與驗證-token-掛載"><a href="#Pod-指定-ServiceAccount-與驗證-token-掛載" class="headerlink" title="Pod 指定 ServiceAccount 與驗證 token 掛載"></a>Pod 指定 ServiceAccount 與驗證 token 掛載</h3><p>✅ 指定 ServiceAccount 給 Pod</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dashboard</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">my-kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">serviceAccountName:</span> <span class="string">dashboard-sa</span></span><br></pre></td></tr></table></figure>

<p>❌ 若不想自動掛載 token</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">my-kubernetes-dashboard</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">dashboard</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">my-kubernetes-dashboard</span></span><br><span class="line">  <span class="attr">automountServiceAccountToken:</span> <span class="literal">false</span>  <span class="comment"># 用來停用自動掛載 SA token（常用於強化安全性）</span></span><br></pre></td></tr></table></figure>

<p>✅ 驗證 token 是否掛載</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl <span class="built_in">exec</span> -it my-kubernetes-dashboard -- <span class="built_in">ls</span> /var/run/secrets/kubernetes.io/serviceaccount</span><br><span class="line">kubectl <span class="built_in">exec</span> -it my-kubernetes-dashboard -- <span class="built_in">cat</span> /var/run/secrets/kubernetes.io/serviceaccount/token</span><br></pre></td></tr></table></figure>

<h3 id="✅-與-RBAC-結合：授權-ServiceAccount-權限"><a href="#✅-與-RBAC-結合：授權-ServiceAccount-權限" class="headerlink" title="✅ 與 RBAC 結合：授權 ServiceAccount 權限"></a>✅ 與 RBAC 結合：授權 ServiceAccount 權限</h3><p>YAML 範例：為特定 ServiceAccount 綁定 ClusterRole</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">rbac.authorization.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ClusterRoleBinding</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">dashboard-sa-binding</span></span><br><span class="line"><span class="attr">subjects:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="attr">kind:</span> <span class="string">ServiceAccount</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">dashboard-sa</span></span><br><span class="line">    <span class="attr">namespace:</span> <span class="string">default</span></span><br><span class="line"><span class="attr">roleRef:</span></span><br><span class="line">  <span class="attr">kind:</span> <span class="string">ClusterRole</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">view</span></span><br><span class="line">  <span class="attr">apiGroup:</span> <span class="string">rbac.authorization.k8s.io</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="ServiceAccount-vs-User-Account"><a href="#ServiceAccount-vs-User-Account" class="headerlink" title="ServiceAccount vs User Account"></a>ServiceAccount vs User Account</h1><p>K8s 有兩種 account。</p>
<table>
<thead>
<tr>
<th>類型</th>
<th>使用對象</th>
<th>身份用途</th>
<th>建立方式</th>
</tr>
</thead>
<tbody><tr>
<td>User Account</td>
<td>實體使用者（如 admin、developer）</td>
<td>與外部系統整合（如 OIDC 認證）</td>
<td>不由 K8s 管理</td>
</tr>
<tr>
<td>Service Account</td>
<td>工作負載（如 Pod、CronJob、Prometheus、Jenkins 等）</td>
<td>提供內部 API 認證身份</td>
<td>由 K8s 自動建立與管理</td>
</tr>
</tbody></table>
<hr>
<h1 id="v1-22-vs-v1-24"><a href="#v1-22-vs-v1-24" class="headerlink" title="v1.22 vs. v1.24"></a>v1.22 vs. v1.24</h1><h2 id="🔐-v1-22-ServiceAccount-Token-安全性改進"><a href="#🔐-v1-22-ServiceAccount-Token-安全性改進" class="headerlink" title="🔐 v1.22+ ServiceAccount Token 安全性改進"></a>🔐 v1.22+ ServiceAccount Token 安全性改進</h2><p>KEP-1205: Bound Service Account Tokens</p>
<ul>
<li>預設 token 為短期有效（time-bound）</li>
<li>token 綁定於特定 audience（audience-bound）</li>
<li>不能被移作他用（object-bound）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl get pod my-kubernetes-dashboard -o yaml</span><br></pre></td></tr></table></figure>

<p>你可以在 Pod Spec 中看到</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">serviceAccountToken:</span><br><span class="line">  expirationSeconds: 3600</span><br></pre></td></tr></table></figure>

<h2 id="🔐-v1-24-減少-Secret-based-Token-的使用"><a href="#🔐-v1-24-減少-Secret-based-Token-的使用" class="headerlink" title="🔐 v1.24+ 減少 Secret-based Token 的使用"></a>🔐 v1.24+ 減少 Secret-based Token 的使用</h2><p>KEP-2799: ServiceAccount 不再自動產生 Secret-based Token<br>Kubernetes v1.24 起，ServiceAccount 預設不再自動建立 Secret-based token，取而代之的是：</p>
<ul>
<li>使用 <strong>TokenRequest API</strong> 動態取得短期有效的 Token</li>
<li>Secret 型 token 僅在需要長期掛載時手動建立</li>
<li>減少長效憑證洩漏風險</li>
</ul>
<p>✅ 動態建立短期有效 token（推薦方式）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">kubectl create token dashboard-sa</span><br></pre></td></tr></table></figure>
<blockquote>
<p>預設有效期限為 1 小時（可使用 <code>--duration=2h</code> 調整）</p>
</blockquote>
<p>✅ 若仍需手動建立 Secret-based Token（不推薦，但必要時可用）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Secret</span><br><span class="line"><span class="built_in">type</span>: kubernetes.io/service-account-token</span><br><span class="line">metadata:</span><br><span class="line">  name: mysecretname</span><br><span class="line">  annotations:</span><br><span class="line">    kubernetes.io/service-account.name: dashboard-sa</span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️ 建立後 Kubernetes 會自動填入 token 與 ca.crt，但這個方式只適用於特定場景（如某些外部整合），不建議一般使用者使用。</p>
</blockquote>
<div class="note info"><p>v1.22 與 v1.24 差異補充說明</p>
<table>
<thead>
<tr>
<th>Kubernetes 版本</th>
<th>Token 行為</th>
</tr>
</thead>
<tbody><tr>
<td>v1.21 以下</td>
<td>預設建立長效 Secret token 並掛載</td>
</tr>
<tr>
<td>v1.22</td>
<td>引入 Bound Token，可控制存活時間 &#x2F; 使用對象</td>
</tr>
<tr>
<td>v1.24 起</td>
<td>預設 <strong>不再建立 Secret token</strong>，必須用 <code>kubectl create token</code> 動態請求</td>
</tr>
</tbody></table>
<p>ServiceAccount Token 使用流程（文字流程圖）</p>
<ol>
<li>Pod 啟動後 → 掛載綁定的 ServiceAccount</li>
<li>若版本 &lt; v1.24 → 自動掛載 Secret Token</li>
<li>若版本 &gt;&#x3D; v1.24 → 建議用 <code>kubectl create token</code> 動態取得</li>
<li>使用 Token → 向 API Server 發送帶有 Bearer Token 的請求</li>
</ol>
</div>

<h2 id="快速產生測試角色與綁定"><a href="#快速產生測試角色與綁定" class="headerlink" title="快速產生測試角色與綁定"></a>快速產生測試角色與綁定</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 建立允許讀取 Pod 的角色</span></span><br><span class="line">kubectl create role pod-reader \</span><br><span class="line">  --verb=get,list,watch \</span><br><span class="line">  --resource=pods \</span><br><span class="line">  --namespace=default</span><br><span class="line"></span><br><span class="line"><span class="comment"># 綁定角色給 serviceaccount</span></span><br><span class="line">kubectl create rolebinding pod-reader-binding \</span><br><span class="line">  --role=pod-reader \</span><br><span class="line">  --serviceaccount=default:dashboard-sa \</span><br><span class="line">  --namespace=default</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用這個方式可快速在 CKA 考試中為特定 ServiceAccount 授權對資源（如 pods）的讀取權限，省下寫 YAML 的時間。</p>
</blockquote>
<h2 id="實務範例：手動使用-Token-呼叫-API-Server"><a href="#實務範例：手動使用-Token-呼叫-API-Server" class="headerlink" title="實務範例：手動使用 Token 呼叫 API Server"></a>實務範例：手動使用 Token 呼叫 API Server</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl https://&lt;api-server&gt;:6443/api \</span><br><span class="line">  --insecure \</span><br><span class="line">  --header <span class="string">&quot;Authorization: Bearer &lt;YOUR_TOKEN&gt;&quot;</span></span><br></pre></td></tr></table></figure>

<hr>
<h1 id="CKA-怎麼考？"><a href="#CKA-怎麼考？" class="headerlink" title="CKA 怎麼考？"></a>CKA 怎麼考？</h1><p>題目通常給你一個情境，例如：</p>
<ul>
<li>建立一個 ServiceAccount</li>
<li>建立 Role &#x2F; ClusterRole（ex: 讀取某資源）</li>
<li>建立對應的 Binding</li>
<li>建立 Pod 並使用該 ServiceAccount</li>
<li>驗證是否能成功使用 API Token 存取資源</li>
</ul>
<p>重點技巧：</p>
<ul>
<li>快速使用 <code>kubectl create</code> 建立 SA &#x2F; Role &#x2F; RoleBinding</li>
<li>熟悉修改 Pod yaml 並套用</li>
<li>驗證 token 掛載與權限（可用 <code>curl</code> + <code>Bearer</code>）</li>
</ul>
<hr>
<h1 id="小結"><a href="#小結" class="headerlink" title="小結"></a>小結</h1><ul>
<li>ServiceAccount 是工作負載與 API Server 通訊的核心機制</li>
<li>建議搭配 RBAC 精確授權</li>
<li>注意 token 掛載行為在 v1.22 &#x2F; v1.24 有重大變更</li>
<li>CKA 考題會實作 SA + RBAC + Pod 驗證整合能力</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>RBAC</tag>
        <tag>CKA</tag>
        <tag>ServiceAccount</tag>
        <tag>Security</tag>
      </tags>
  </entry>
  <entry>
    <title>K8s Security | 憑證檢查與 ETCD 日誌診斷實務</title>
    <url>/2025/07/07/K8s-Advanced/K8s-Security-%E6%86%91%E8%AD%89%E6%AA%A2%E6%9F%A5%E8%88%87ETCD%E6%97%A5%E8%AA%8C%E8%A8%BA%E6%96%B7%E5%AF%A6%E5%8B%99/</url>
    <content><![CDATA[<h1 id="View-Certificate-Details"><a href="#View-Certificate-Details" class="headerlink" title="View Certificate Details"></a>View Certificate Details</h1><h2 id="檢視-K8s-API-Server-憑證詳細資訊"><a href="#檢視-K8s-API-Server-憑證詳細資訊" class="headerlink" title="檢視 K8s API Server 憑證詳細資訊"></a>檢視 K8s API Server 憑證詳細資訊</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看憑證內容</span></span><br><span class="line">openssl x509 -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver.crt -text -noout</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>欄位</th>
<th>說明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Certificate Path</strong></td>
<td><code>/etc/kubernetes/pki/apiserver.crt</code> 檔案位置</td>
</tr>
<tr>
<td><strong>CN Name</strong></td>
<td><code>Subject: CN=</code>，常見為 <code>kube-apiserver</code> 或主機名稱</td>
</tr>
<tr>
<td><strong>ALT Names</strong></td>
<td><code>X509v3 Subject Alternative Name</code>，列出支援的 DNS&#x2F;IP</td>
</tr>
<tr>
<td><strong>Organization</strong></td>
<td><code>Subject: O=</code>，通常是 <code>system:masters</code></td>
</tr>
<tr>
<td><strong>Issuer</strong></td>
<td>憑證簽發者，來自 CA 的 CN</td>
</tr>
<tr>
<td><strong>Expiration</strong></td>
<td><code>Not After</code> 欄位表示的憑證過期時間</td>
</tr>
</tbody></table>
<h2 id="範例解析欄位（從-openssl-輸出中提取）"><a href="#範例解析欄位（從-openssl-輸出中提取）" class="headerlink" title="範例解析欄位（從 openssl 輸出中提取）"></a>範例解析欄位（從 openssl 輸出中提取）</h2><ol>
<li><p>Subject:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Subject: O=system:masters, CN=kube-apiserver</span><br></pre></td></tr></table></figure>
</li>
<li><p>Subject Alternative Name:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">X509v3 Subject Alternative Name:</span><br><span class="line">    DNS:kubernetes, DNS:kubernetes.default, IP Address:10.96.0.1, ...</span><br></pre></td></tr></table></figure>
</li>
<li><p>Validity - Not After:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Not After : Jul  5 10:33:24 2025 GMT</span><br></pre></td></tr></table></figure>
</li>
<li><p>Issuer:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Issuer: CN=kubernetes-ca</span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="Inspect-Service-Logs"><a href="#Inspect-Service-Logs" class="headerlink" title="Inspect Service Logs"></a>Inspect Service Logs</h1><h2 id="查看-etcd-服務狀態與日誌"><a href="#查看-etcd-服務狀態與日誌" class="headerlink" title="查看 etcd 服務狀態與日誌"></a>查看 etcd 服務狀態與日誌</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用 journalctl 查看 systemd 啟動日誌</span></span><br><span class="line">journalctl -u etcd.service -l</span><br><span class="line">journalctl -u etcd.service -l --no-pager</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--no-pager</code>：可避免分頁輸出。<br><code>-l</code>（long&#x2F;full）：顯示不被截斷的完整日誌內容。</p>
</blockquote>
<hr>
<h1 id="View-etcd-Logs（依部署方式而定）"><a href="#View-etcd-Logs（依部署方式而定）" class="headerlink" title="View etcd Logs（依部署方式而定）"></a>View etcd Logs（依部署方式而定）</h1><h2 id="若-etcd-為-Kubernetes-static-Pod（預設情況）"><a href="#若-etcd-為-Kubernetes-static-Pod（預設情況）" class="headerlink" title="若 etcd 為 Kubernetes static Pod（預設情況）"></a>若 etcd 為 Kubernetes static Pod（預設情況）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 靜態 Pod 名稱通常為 etcd-[node-name]，可用以下指令查詢</span></span><br><span class="line">kubectl get pods -n kube-system -o wide</span><br><span class="line">kubectl logs etcd-[node-name] -n kube-system</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用 <code>kubectl get pods -n kube-system</code> 確認實際 Pod 名稱</p>
</blockquote>
<h2 id="若-etcd-是以-Docker-container-運行"><a href="#若-etcd-是以-Docker-container-運行" class="headerlink" title="若 etcd 是以 Docker container 運行"></a>若 etcd 是以 Docker container 運行</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker ps -a  <span class="comment"># 找出 etcd container ID 或名稱</span></span><br><span class="line">docker logs [container_id or container_name]</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="其他實用檢查指令"><a href="#其他實用檢查指令" class="headerlink" title="其他實用檢查指令"></a>其他實用檢查指令</h1><h2 id="檢查-kube-apiserver-的證書與密鑰是否配對"><a href="#檢查-kube-apiserver-的證書與密鑰是否配對" class="headerlink" title="檢查 kube-apiserver 的證書與密鑰是否配對"></a>檢查 kube-apiserver 的證書與密鑰是否配對</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl x509 -noout -modulus -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver.crt | openssl md5</span><br><span class="line">openssl rsa -noout -modulus -<span class="keyword">in</span> /etc/kubernetes/pki/apiserver.key | openssl md5</span><br></pre></td></tr></table></figure>
<blockquote>
<p>兩者輸出應一致，否則代表證書與密鑰不配對。</p>
</blockquote>
<h2 id="驗證-etcd-通訊加密（如使用自簽憑證）"><a href="#驗證-etcd-通訊加密（如使用自簽憑證）" class="headerlink" title="驗證 etcd 通訊加密（如使用自簽憑證）"></a>驗證 etcd 通訊加密（如使用自簽憑證）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">openssl s_client -connect 127.0.0.1:2379 \</span><br><span class="line">  -cert /etc/kubernetes/pki/etcd/server.crt \</span><br><span class="line">  -key /etc/kubernetes/pki/etcd/server.key \</span><br><span class="line">  -CAfile /etc/kubernetes/pki/etcd/ca.crt</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>Certificate</tag>
        <tag>openssl</tag>
        <tag>logs</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes | Cluster Architecture</title>
    <url>/2024/04/16/Kubernetes/Kubernetes-Cluster-Architecture/</url>
    <content><![CDATA[<p><code>Kubernetes</code></p>
<ul>
<li>目的是讓容器（Container）的管理變得容易、允許被監控且自動化。</li>
</ul>
<p><code>Node</code></p>
<ul>
<li><code>指的是 Worker Nodes 的部分，不是 Master ！</code></li>
<li>A node is a worker machine in Kubernetes. A worker node may be a VM or physical machine, depending on the cluster. </li>
<li>It has local daemons or services necessary to run Pods and is managed by the control plane. The daemons on a node include kubelet, kube-proxy, and a container runtime implementing the CRI such as Docker.</li>
</ul>
<p><code>Container</code></p>
<ul>
<li>輕量級的容器，打包所有必要且相依的套件、程式碼等，提供應用程式一致的運行環境，使應用程式在不同的作業系統上也能夠重建和運行。</li>
</ul>
<h1 id="Kubernetes-Cluster-Architecture"><a href="#Kubernetes-Cluster-Architecture" class="headerlink" title="Kubernetes Cluster Architecture"></a>Kubernetes Cluster Architecture</h1><p>Kubernetes cluster architecture<br><img src="https://kubernetes.io/images/docs/kubernetes-cluster-architecture.svg"></p>
<h1 id="Kubernetes-Components"><a href="#Kubernetes-Components" class="headerlink" title="Kubernetes Components"></a>Kubernetes Components</h1><p>The components of a Kubernetes cluster<br><img src="https://kubernetes.io/images/docs/components-of-kubernetes.svg"></p>
<h2 id="【-Master-】"><a href="#【-Master-】" class="headerlink" title="【 Master 】"></a><font color=LightCoral>【 Master 】</font></h2><blockquote>
<p>aka. 【 Control Plane Components 】<br>職責：<code>負責監控與管理容器</code></p>
</blockquote>
<p><font color=LightCoral>Purpose: Manage, Plan, Schedule, Monitor Nodes</font></p>
<h3 id="kube-apiserver"><a href="#kube-apiserver" class="headerlink" title="kube-apiserver"></a>kube-apiserver</h3><p>Also known as: API server</p>
<p>The API server is a component of the Kubernetes control plane that exposes the Kubernetes API. The API server is the front end for the Kubernetes control plane.</p>
<p>📌 K8s 最高層次的管理介面，負責協調集群中的所有操作。</p>
<h3 id="etcd"><a href="#etcd" class="headerlink" title="etcd"></a>etcd</h3><p>Consistent and highly-available key value store used as Kubernetes’ backing store for all cluster data.<br>The official etcd ports are 2379 for client requests and 2380 for peer communication.</p>
<p>📌 負責儲存關於集群的資訊，包括 Nodes、PODs、Configs、Secrets、Accounts、Roles、Bindings 和 Others。<br>📌 ETCD in HA Environment：一個集群（Cluster）中，可以有多個 master。每個 master 裡面都有一個 ETCD。</p>
<h3 id="kube-scheduler"><a href="#kube-scheduler" class="headerlink" title="kube-scheduler"></a>kube-scheduler</h3><p>Control plane component that watches for newly created Pods with no assigned node, and selects a node for them to run on.</p>
<p>Factors taken into account for scheduling decisions include: individual and collective resource requirements, hardware&#x2F;software&#x2F;policy constraints, affinity and anti-affinity specifications, data locality, inter-workload interference, and deadlines.</p>
<p>📌 負責調度節點上的容器或應用程序。基於容器的資源需求、Worker Node 容量、任何其他策略或約束，來識別正確的節點以放置容器。<br>📌 只負責決定哪個 pod 在哪個 node 上運行，而非實際將 pod 放在 node 上。</p>
<h3 id="kube-controller-manager"><a href="#kube-controller-manager" class="headerlink" title="kube-controller-manager"></a>kube-controller-manager</h3><p>Control plane component that runs controller processes.</p>
<p>There are many different types of controllers. (e.g. Node controller, Job controller, EndpointSlice controller, ServiceAccount controller …)</p>
<p>📌 不同控制器，處理不同的功能。目的是持續監看容器的狀態、當容器掛掉時採取補救行動。</p>
<h2 id="【-Worker-Nodes-】"><a href="#【-Worker-Nodes-】" class="headerlink" title="【 Worker Nodes 】"></a><font color=LightCoral>【 Worker Nodes 】</font></h2><blockquote>
<p>aka. 【 Node Components 】<br>職責：<code>負責裝載容器</code></p>
</blockquote>
<p><font color=LightCoral>Purpose: Host Application as Containers</font></p>
<h3 id="kubelet"><a href="#kubelet" class="headerlink" title="kubelet"></a>kubelet</h3><p>An agent that runs on each node in the cluster. It makes sure that containers are running (and healthy) in a Pod.</p>
<p>📌 相當於船長，是在集群中各個 worker nodes（船隻）上運行的代理人，負責與 master 溝通、回報 pod 狀態，聽從 kube-apiserver 的指令來管理容器。例如：根據需要在 worker node 上部署或銷毀容器。</p>
<h3 id="kube-proxy"><a href="#kube-proxy" class="headerlink" title="kube-proxy"></a>kube-proxy</h3><p>kube-proxy is a network proxy that runs on each node in your cluster, implementing part of the Kubernetes Service concept.</p>
<p>kube-proxy maintains network rules on nodes. These network rules allow network communication to your Pods from network sessions inside or outside of your cluster.</p>
<p>📌 負責集群內不同 worker node 之間的通訊。</p>
<h3 id="Container-runtime"><a href="#Container-runtime" class="headerlink" title="Container runtime"></a>Container runtime</h3><p>A fundamental component that empowers Kubernetes to run containers effectively. It is responsible for managing the execution and lifecycle of containers within the Kubernetes environment.</p>
<p>Kubernetes supports container runtimes such as containerd, CRI-O, rkt, and any other implementation of the Kubernetes CRI (Container Runtime Interface).</p>
<p>📌 Container 是運行應用程式的獨立環境。</p>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://kubernetes.io/docs/concepts/architecture/">Cluster Architecture</a></li>
<li><a href="https://kubernetes.io/docs/concepts/overview/components/">Kubernetes Components</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>觀念解說</tag>
        <tag>Concepts</tag>
        <tag>Architecture</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes | Deployment</title>
    <url>/2024/06/10/Kubernetes/Kubernetes-Deployment/</url>
    <content><![CDATA[<h1 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h1><p>An API object that manages a replicated application, typically by running Pods with no local state.</p>
<p>📌 A Kubernetes Deployment is a higher-level object that provides capabilities such as <code>seamless rolling updates to underlying instances</code>, <code>the ability to undo changes</code>, and the option to <code>pause and resume changes as required</code>.<br>📌 Kubernetes Deployments are commonly used to deploy and manage multiple instances of applications in a <code>production environment</code>.</p>
<img src="/2024/06/10/Kubernetes/Kubernetes-Deployment/Kubernetes_Deployment.jpg" class="">

<h1 id="Key-Reasons-for-Using-a-Deployment"><a href="#Key-Reasons-for-Using-a-Deployment" class="headerlink" title="Key Reasons for Using a Deployment"></a>Key Reasons for Using a Deployment</h1><ol>
<li><code>Rolling Updates</code>: <ul>
<li>This allows for seamless updates to the underlying instances (pods) without downtime by gradually replacing the old versions of pods with new ones.</li>
<li><code>Don&#39;t upgrade all at once</code>, as it may impact users accessing your applications. Instead, upgrade one after the other, using a process called rolling updates.</li>
</ul>
</li>
<li><code>Rollback</code>:<ul>
<li>If something goes wrong during an update, a Deployment can undo changes and revert to a previous stable state.</li>
<li>Undo the recent change. Roll back the changes that were recently carried out.</li>
</ul>
</li>
<li><code>Pause and Resume</code>: <ul>
<li>Updates can be paused and resumed, which is useful for controlling the deployment process and debugging issues.</li>
<li>You don’t want to apply each change immediately after the command is run. Instead, you would like to apply a pause to your environment, make the changes, and then resume so that all the changes are rolled out together.</li>
</ul>
</li>
</ol>
<hr>
<h1 id="Deployment-with-YAML"><a href="#Deployment-with-YAML" class="headerlink" title="Deployment with YAML"></a>Deployment with YAML</h1><p>Template:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> [<span class="string">custom_name</span>]</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    [<span class="string">custom_key</span>]<span class="string">:</span> [<span class="string">custom_value</span>]</span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    [[ <span class="string">POD</span> ]]</span><br><span class="line">  <span class="attr">replicas:</span> [<span class="string">number</span>]</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      [<span class="string">pod_labels_key</span>]<span class="string">:</span> [<span class="string">pod_labels_value</span>]</span><br></pre></td></tr></table></figure>

<p>deployment-definition.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">front-end</span></span><br></pre></td></tr></table></figure>

<p>RUN commands</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f deployment-definition.yml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get deployments</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get replicaset</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br></pre></td></tr></table></figure>
<img src="/2024/06/10/Kubernetes/Kubernetes-Deployment/Deployment_commands_1.jpg" class="">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get all</span></span><br></pre></td></tr></table></figure>
<img src="/2024/06/10/Kubernetes/Kubernetes-Deployment/Deployment_commands_2.jpg" class="">


<p>👍 Quickly create Kubernetes YAML Templates<br>In k8s version 1.19+, we can specify the –replicas option to create a deployment with 3 replicas.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment --image=httpd:2.4-alpine httpd-frontend --replicas=3</span></span><br></pre></td></tr></table></figure>

<h2 id="kubectl-create-vs-kubectl-run"><a href="#kubectl-create-vs-kubectl-run" class="headerlink" title="kubectl create vs. kubectl run"></a>kubectl create vs. kubectl run</h2><h3 id="📝-kubectl-create"><a href="#📝-kubectl-create" class="headerlink" title="📝 kubectl create"></a>📝 kubectl create</h3><blockquote>
<p>Create a resource from a file or from stdin.<br>JSON and YAML formats are accepted.</p>
</blockquote>
<p>Create a deployment</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment --image=nginx nginx</span></span><br></pre></td></tr></table></figure>

<p>Generate Deployment YAML file (-o yaml). Don’t create it(–dry-run) and save it to a file.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment --image=nginx nginx --dry-run=client -o yaml &gt; nginx-deployment.yaml</span></span><br></pre></td></tr></table></figure>

<p>Make necessary changes to the file (for example, adding more replicas) and then create the deployment.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f nginx-deployment.yaml</span></span><br></pre></td></tr></table></figure>


<h3 id="📝-kubectl-run"><a href="#📝-kubectl-run" class="headerlink" title="📝 kubectl run"></a>📝 kubectl run</h3><blockquote>
<p>Create and run a particular image in a <code>pod</code>.</p>
</blockquote>
<p>Create an NGINX Pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl run nginx --image=nginx</span></span><br></pre></td></tr></table></figure>

<p>Generate POD Manifest YAML file (-o yaml). Don’t create it (–dry-run) and save it to a file.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl run redis --image=redis --dry-run=client -o yaml &gt; redis_template.yaml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f redis_template.yaml</span></span><br></pre></td></tr></table></figure>


<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/deployment/">Deployment</a></li>
<li><a href="https://kubernetes.io/docs/reference/kubectl/generated/kubectl_create/">kubectl create</a></li>
<li><a href="https://kubernetes.io/docs/reference/kubectl/generated/kubectl_run/">kubectl run</a></li>
<li><a href="https://kubernetes.io/docs/reference/kubectl/conventions/">kubectl Usage Conventions</a> 👍</li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>觀念解說</tag>
        <tag>Concepts</tag>
        <tag>Deployment</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes | Pods</title>
    <url>/2024/05/14/Kubernetes/Kubernetes-Pods/</url>
    <content><![CDATA[<h1 id="Pods"><a href="#Pods" class="headerlink" title="Pods"></a>Pods</h1><p>📌 Kubernetes doesn’t deploy containers directly on the worker node. The containers are encapsulated into “pods”.<br>📌 A pod is a single instance of an application. A pod is the smallest object that you can create in Kubernetes.</p>
<h2 id="Why-does-Kubernetes-use-pods-🤔"><a href="#Why-does-Kubernetes-use-pods-🤔" class="headerlink" title="Why does Kubernetes use pods? 🤔"></a><a href="https://www.redhat.com/en/topics/containers/what-is-kubernetes-pod">Why does Kubernetes use pods?</a> 🤔</h2><p>Pods are designed to have one (common use case) or more (advanced use cases) containers.</p>
<p>Grouping containers in this way allows them to communicate with each other, while still remaining isolated to some degree. Containers in a single pod are designed to share common compute resources, such as same storage, same network, same namespace, and be created together and destroyed together. </p>
<p>This is a good thing in the long run because your application is now ready to handle future architectural changes and scale. Organizing containers into pods allows horizontal scalability of applications. Pods can be replicated across different nodes, enabling resistance to failure. </p>
<h2 id="The-simplest-case"><a href="#The-simplest-case" class="headerlink" title="The simplest case"></a>The simplest case</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">        Big        &gt; ----------- &gt; --- &gt; --------- &gt;    Small</span><br><span class="line">Kubernetes Cluster &gt; Worker Node &gt; Pod &gt; Container &gt; Application</span><br></pre></td></tr></table></figure>

<p>The image below contains the following components:</p>
<ul>
<li>A Kubernetes cluster</li>
<li>A single worker node</li>
<li>A single pod</li>
<li>A single container</li>
<li>A single application</li>
</ul>
<p>Explanation:<br><code>A single-node Kubernetes cluster</code> with <code>a single instance of your application</code> running in <code>a single Docker container</code> encapsulated in <code>a single pod</code>.</p>
<img src="/2024/05/14/Kubernetes/Kubernetes-Pods/Kubernetes_Pod.jpg" class="">


<h2 id="Best-Practice"><a href="#Best-Practice" class="headerlink" title="Best Practice"></a>Best Practice</h2><p>📌 Pods usually have a one-to-one relationship with containers running your application. Multiple containers running in a Pod is a rare use case.</p>
<p>📌 Don’t add additional (same kind) containers to an existing pod to scale your application!</p>
<blockquote>
<p>A Pod contains at most one container of the same type.</p>
<img src="/2024/05/14/Kubernetes/Kubernetes-Pods/Pod_scale_up_1.jpg" class="">
</blockquote>
<p>📌 當連線到應用程式的使用者增加時，該如何擴展你的應用程式來分攤負載（share the load）？</p>
<blockquote>
<p><code>[ X ]</code> 在同一個 Pod 中，啟動新的 Container。<br>(A cluster, a worker node, two containers in a pod)</p>
</blockquote>
<blockquote>
<p><code>[ O ]</code> 新增一個 Pod ，並在其中啟動新的 Container。<br>(A cluster, a worker node, two pods, a container in a pod)</p>
</blockquote>
<blockquote>
<p><code>[ O ]</code> 若當前 worker node 沒有足夠容量時，新增一個 worker node，並在該 worker node 上新增一個 Pod，接著在 Pod 上啟動新的 container。<br>(A cluster, two worker nodes, a worker node can have multiple pods, a container in a pod)</p>
</blockquote>
<hr>
<h1 id="圖解-Kubectl-Command"><a href="#圖解-Kubectl-Command" class="headerlink" title="圖解 Kubectl Command"></a>圖解 Kubectl Command</h1><p>📌 Kubectl Command 會自動創建一個 Pod，並在其內部署一個 Container。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl run nginx --image nginx</span></span><br></pre></td></tr></table></figure>
<img src="/2024/05/14/Kubernetes/Kubernetes-Pods/kubectl_run_nginx_1.jpg" class="">
<img src="/2024/05/14/Kubernetes/Kubernetes-Pods/kubectl_run_nginx_2.jpg" class="">

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br></pre></td></tr></table></figure>
<img src="/2024/05/14/Kubernetes/Kubernetes-Pods/kubectl_get_pods.jpg" class="">


<h1 id="YAML-in-Kubernetes"><a href="#YAML-in-Kubernetes" class="headerlink" title="YAML in Kubernetes"></a>YAML in Kubernetes</h1><ul>
<li>Note: <ul>
<li>apiVersion: string</li>
<li>kind: string</li>
<li>metadata: dictionary</li>
<li>containers: list&#x2F;array</li>
</ul>
</li>
<li>Check “kind” for pod&#x2F;replicationcontroller&#x2F;replicaset&#x2F;deployment&#x2F;service<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl explain [pod | replicationcontroller | replicaset | deployment | service]</span></span><br></pre></td></tr></table></figure></li>
<li>Help<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create deployment --<span class="built_in">help</span></span></span><br></pre></td></tr></table></figure></li>
</ul>
<p>definition.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> [<span class="string">v1</span> <span class="string">|</span> <span class="string">apps/v1</span>]</span><br><span class="line"><span class="attr">kind:</span> [<span class="string">Pod</span> <span class="string">|</span> <span class="string">Service</span> <span class="string">|</span> <span class="string">ReplicaSet</span> <span class="string">|</span> <span class="string">Deployment</span>]</span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> [<span class="string">custom_name</span>]</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    [<span class="string">custom_key_1</span>]<span class="string">:</span> [<span class="string">custom_value_1</span>]</span><br><span class="line">    [<span class="string">custom_key_2</span>]<span class="string">:</span> [<span class="string">custom_value_2</span>]</span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> [<span class="string">container1_name</span>]</span><br><span class="line">      <span class="attr">image:</span> [<span class="string">image1_name</span>]</span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> [<span class="string">container2_name</span>]</span><br><span class="line">      <span class="attr">image:</span> [<span class="string">image2_name</span>]</span><br><span class="line">    <span class="string">...</span></span><br></pre></td></tr></table></figure>

<p>👍 Quickly create Kubernetes YAML Templates</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl run redis --image=redis --dry-run=client -o yaml &gt; redis_template.yaml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f redis_template.yaml</span></span><br></pre></td></tr></table></figure>


<h2 id="Pods-with-YAML"><a href="#Pods-with-YAML" class="headerlink" title="Pods with YAML"></a>Pods with YAML</h2><p>pod-definition.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Pod</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">containers:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">      <span class="attr">image:</span> <span class="string">nginx</span></span><br></pre></td></tr></table></figure>

<p>Run pod-definition.yml</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f pod-definition.yml</span></span><br><span class="line">or</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl apply -f pod-definition.yml</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods -o wide</span></span><br></pre></td></tr></table></figure>
<img src="/2024/05/14/Kubernetes/Kubernetes-Pods/kubectl_create_pod_1.jpg" class="">

<p>View Pod details</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl describe pod [myapp-pod]</span></span><br></pre></td></tr></table></figure>
<img src="/2024/05/14/Kubernetes/Kubernetes-Pods/kubectl_create_pod_2.jpg" class="">

<p>Delete Pod</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete pod [myapp-pod]</span></span><br></pre></td></tr></table></figure>


<h2 id="Service-with-YAML"><a href="#Service-with-YAML" class="headerlink" title="Service with YAML"></a>Service with YAML</h2><p>service-definition.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="ReplicaSet-with-YAML"><a href="#ReplicaSet-with-YAML" class="headerlink" title="ReplicaSet with YAML"></a>ReplicaSet with YAML</h2><p>replicaset-definition.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-replicaset</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">front-end</span></span><br></pre></td></tr></table></figure>


<h2 id="Deployment-with-YAML"><a href="#Deployment-with-YAML" class="headerlink" title="Deployment with YAML"></a>Deployment with YAML</h2><p>deployment-definition.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Deployment</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-deployment</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">front-end</span></span><br></pre></td></tr></table></figure>


<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://www.redhat.com/en/topics/containers/what-is-kubernetes-pod">What is a Kubernetes pod?</a></li>
<li><a href="https://www.reddit.com/r/kubernetes/comments/u1xva3/newbie_why_are_pods_needed/">Newbie: Why are pods needed?</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>觀念解說</tag>
        <tag>Concepts</tag>
        <tag>Pods</tag>
        <tag>Kubectl</tag>
        <tag>YAML</tag>
      </tags>
  </entry>
  <entry>
    <title>ChatGPT 職場革命：PM 不需程式技能也能高效工作</title>
    <url>/2024/07/16/Workplace/ChatGPT-%E8%81%B7%E5%A0%B4%E9%9D%A9%E5%91%BD%EF%BC%9APM-%E4%B8%8D%E9%9C%80%E7%A8%8B%E5%BC%8F%E6%8A%80%E8%83%BD%E4%B9%9F%E8%83%BD%E9%AB%98%E6%95%88%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<p>最近工作上發生了一件事，讓我對於 ChatGPT 的應用有了不一樣的想法，也在工作流程中感受到其帶來的好處與潛在的衝擊。</p>
<h1 id="【-前情提要-】"><a href="#【-前情提要-】" class="headerlink" title="【 前情提要 】"></a>【 前情提要 】</h1><p>我是一位雲端系統工程師，除了負責雲端平台的維運及開發、資料庫建置與管理（尤其是資料庫 service 掛掉，光是找原因和修復 Replica Set 就快搞死我了 T _ T ）之外，還要配合其他部門不定期的&#x2F;異想天開的&#x2F;快要火燒屁股的需求要處理。</p>
<h1 id="【-真人真事-】"><a href="#【-真人真事-】" class="headerlink" title="【 真人真事 】"></a>【 真人真事 】</h1><p>回到正題，由於最近公司接了一些政府標案，目標是建置一個平台顯示 IoT 設備的即時數據、歷史數據，還要針對這些設備顯示其狀態（判斷設備異常、運作狀態，甚至 GPS 定位）以及各種功能。</p>
<p>可想而知，過程是重重的挑戰與艱辛（心酸血淚史XD 特別是溝通、取得和整理成標準化的資料，常常讓人感到心累 😱 Orz），更別說開發時程短（要在短時間內於不同環境下測試 Development -&gt; Testing -&gt; Staging -&gt; Production）、處理細項雜（不只串接 API 資料、MQTT 傳送資料，還要檢核資料的合理性…），根本忙到炸掉啊！</p>
<p>當然，我都這麼忙了，我們的 PM 也好不到哪裡去，根本是被科長、承辦、各種報告追殺。<br>嗚呼哀哉！看著 PM 幾乎每天在加班中度過，每天想盡辦法、絞盡腦汁地想要提高工作效率。<br>而最終，PM 把腦筋動到了 ChatGPT 上。</p>
<p>有處理過很大量且髒亂資料的人就會知道，如果要讓人去手動處理並不是不行，但會非常的耗時且容易人為出錯，而且這種事情都有一定的重複性、不是那麼容易寫成規則用程式執行（例外狀況很多，依舊無法免除人工判斷）。</p>
<p>這位 PM 跟我分享，他拿著我匯出給他的 Excel，花了兩個小時 ChatGPT 訓練了八次，才讓 ChatGPT 瞭解要整理成什麼樣的格式。其餘的部分，才交由人工判斷和調整。</p>
<h1 id="【-心得-】"><a href="#【-心得-】" class="headerlink" title="【 心得 】"></a>【 心得 】</h1><p>說到這裡，不覺得 ChatGPT 這個工具很好用，但同時又有點可怕嗎？🤔</p>
<blockquote>
<p>它讓一個完全不懂寫 code 的 PM 能夠用口語教導 ChatGPT 應該輸出怎樣的格式，而不用勞煩一位忙到處於崩潰邊緣的工程師。<br>可怕的是，它減輕了工程師工作量的同時，也取代了初階工程師的一部分工作內容。</p>
</blockquote>
<p>因此，我覺得未來的人才（不只是工程師），首先要 open-minded 接受新技術、新觀念，再者懂得定義問題（對於複雜問題有抽絲剝繭的能力）也非常關鍵且重要，最後善用 ChatGPT 這類工具有效率地達成目標。<br>我預測未來的工程師，飯碗應該會越來越不好捧了，被預期要學更多技能，要嘛更深入，要嘛更廣泛（前提是知道為何使用、如何應用）。</p>
<h1 id="【-與-PM-對話續集-】"><a href="#【-與-PM-對話續集-】" class="headerlink" title="【 與 PM 對話續集 】"></a>【 與 PM 對話續集 】</h1><p>後來，PM 說他曾試圖看 ChatGPT 的 code，不過看不懂、就算有錯也看不出來（儘管下方有補充說明寫法與為何這樣使用）。<br>我就回他：「你若看懂，就可以取代工程師了。加油！搞不好，改行離你不遠了😎」</p>
]]></content>
      <categories>
        <category>職場隨筆</category>
      </categories>
      <tags>
        <tag>ChatGPT</tag>
        <tag>實際案例</tag>
        <tag>心得</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes | ReplicationController vs. ReplicaSet</title>
    <url>/2024/06/01/Kubernetes/Kubernetes-ReplicationController-vs-ReplicaSet/</url>
    <content><![CDATA[<h1 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h1><h2 id="What-are-Kubernetes-Controllers"><a href="#What-are-Kubernetes-Controllers" class="headerlink" title="What are Kubernetes Controllers?"></a>What are Kubernetes Controllers?</h2><ul>
<li>Brain of Kubernetes: <ul>
<li>Controllers are essentially the decision-makers within the Kubernetes. </li>
<li>They are responsible for observing the state of the cluster and taking actions to ensure the desired state is achieved and maintained.</li>
</ul>
</li>
</ul>
<h2 id="Key-Reasons-for-Using-a-RC"><a href="#Key-Reasons-for-Using-a-RC" class="headerlink" title="Key Reasons for Using a RC"></a>Key Reasons for Using a RC</h2><p>Note: Replication Controller (RC)</p>
<h3 id="Ensuring-High-Availability"><a href="#Ensuring-High-Availability" class="headerlink" title="Ensuring High Availability"></a>Ensuring High Availability</h3><blockquote>
<p>場景一：為了避免只有一個 Pod 且又恰巧崩潰而導致使用者無法使用該應用程式，因此會建議同時運行「多個應用程式副本」，並且一個應用程式只會運行於一個 Pod 內。這新生成的 Pod 會依照 Node 資源使用狀況，被分配到原 Node 或新的 Node 上。</p>
</blockquote>
<ul>
<li>By maintaining multiple replicas of a pod, an RC ensures that your application remains available even if individual pods fail or are terminated. This redundancy is crucial for high availability and fault tolerance.</li>
<li><code>Does that mean you can&#39;t use a Replication Controller if you plan to have a single Pod?</code> 🤔<ul>
<li><code>No.</code> Even if you have a single pod, the Replication Controller can help by automatically bringing up a new pod when the existing one fails.</li>
<li>Thus, the Replication Controller ensures that a specified number of pods are running at all times, even if it’s just 1 or 100.</li>
</ul>
</li>
</ul>
<h3 id="Load-Balancing-Scaling"><a href="#Load-Balancing-Scaling" class="headerlink" title="Load Balancing &amp; Scaling"></a>Load Balancing &amp; Scaling</h3><blockquote>
<p>場景二：為了建立多個 Pod 來共享它們之間的負載。</p>
<img src="/2024/06/01/Kubernetes/Kubernetes-ReplicationController-vs-ReplicaSet/ReplicationController_Load%20Balancing%20&%20Scaling.jpg" class="">
</blockquote>
<ul>
<li>It helps us to share&#x2F;balance the load across multiple pods on different nodes as well as scale our application when the demand increases.</li>
</ul>
<h2 id="ReplicationController-vs-ReplicaSet"><a href="#ReplicationController-vs-ReplicaSet" class="headerlink" title="ReplicationController vs. ReplicaSet"></a>ReplicationController vs. ReplicaSet</h2><ol>
<li>Both have the same purpose, but they are not the same.<ul>
<li>ReplicaSet is the next-generation ReplicationController that supports the new set-based label selector.</li>
<li>The two behave similarly, except that a ReplicationController does not support set-based selector requirements as described in the labels user guide.</li>
</ul>
</li>
<li><code>ReplicaSet</code> is preferred over ReplicationController.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">📌 The selector is one of the major differences between Replication Controller and ReplicaSet.</span><br><span class="line">  - The selector helps the ReplicaSet identify what pods fall under it. ReplicaSet can also manage pods that were not created as part of the ReplicaSet creation.</span><br><span class="line">  - ReplicaSet maintains the desired number of replicas across all pods that fit its criteria (match labels specified in the selector), regardless of whether they were created before (existing pods) or after the ReplicaSet itself.</span><br></pre></td></tr></table></figure>
<img src="/2024/06/01/Kubernetes/Kubernetes-ReplicationController-vs-ReplicaSet/ReplicaSet_selector_label.jpg" class="">


<h3 id="ReplicationController"><a href="#ReplicationController" class="headerlink" title="ReplicationController"></a>ReplicationController</h3><p>A ReplicationController ensures that a specified number of pod replicas are running at any one time. In other words, a ReplicationController makes sure that a pod or a homogeneous set of pods is always up and available.</p>
<h4 id="ReplicationController-with-YAML"><a href="#ReplicationController-with-YAML" class="headerlink" title="ReplicationController with YAML"></a>ReplicationController with YAML</h4><p>Template:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> [<span class="string">custom_name</span>]</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    [<span class="string">custom_key</span>]<span class="string">:</span> [<span class="string">custom_value</span>]</span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    [[ <span class="string">POD</span> ]]</span><br><span class="line">  <span class="attr">replicas:</span> [<span class="string">number</span>]</span><br></pre></td></tr></table></figure>

<p>rc-definition.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicationController</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-rc</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>RUN commands</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f rc-definition.yml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get replicationcontroller</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete rc myapp-rc</span></span><br></pre></td></tr></table></figure>
<img src="/2024/06/01/Kubernetes/Kubernetes-ReplicationController-vs-ReplicaSet/ReplicationController_commands.jpg" class="">


<h3 id="ReplicaSet-👍"><a href="#ReplicaSet-👍" class="headerlink" title="ReplicaSet 👍"></a>ReplicaSet 👍</h3><p>A ReplicaSet’s purpose is to maintain a stable set of replica Pods running at any given time. As such, it is often used to guarantee the availability of a specified number of identical Pods.</p>
<p>It’s mainly used by Deployment as a mechanism to orchestrate pod creation, deletion and updates. Note that we recommend using Deployments instead of directly using Replica Sets, unless you require custom update orchestration or don’t require updates at all.</p>
<h4 id="ReplicaSet-with-YAML"><a href="#ReplicaSet-with-YAML" class="headerlink" title="ReplicaSet with YAML"></a>ReplicaSet with YAML</h4><p>Template:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> [<span class="string">custom_name</span>]</span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    [<span class="string">custom_key</span>]<span class="string">:</span> [<span class="string">custom_value</span>]</span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    [[ <span class="string">POD</span> ]]</span><br><span class="line">  <span class="attr">replicas:</span> [<span class="string">number</span>]</span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      [<span class="string">pod_labels_key</span>]<span class="string">:</span> [<span class="string">pod_labels_value</span>]</span><br></pre></td></tr></table></figure>

<p>replicaset-definition.yml</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">ReplicaSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">myapp-replicaset</span></span><br><span class="line">  <span class="attr">labels:</span></span><br><span class="line">    <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line">  <span class="attr">template:</span></span><br><span class="line">    <span class="attr">metadata:</span></span><br><span class="line">      <span class="attr">name:</span> <span class="string">myapp-pod</span></span><br><span class="line">      <span class="attr">labels:</span></span><br><span class="line">        <span class="attr">app:</span> <span class="string">myapp</span></span><br><span class="line">        <span class="attr">type:</span> <span class="string">front-end</span></span><br><span class="line">    <span class="attr">spec:</span></span><br><span class="line">      <span class="attr">containers:</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">nginx-container</span></span><br><span class="line">          <span class="attr">image:</span> <span class="string">nginx</span></span><br><span class="line">  <span class="attr">replicas:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">selector:</span></span><br><span class="line">    <span class="attr">matchLabels:</span></span><br><span class="line">      <span class="attr">type:</span> <span class="string">front-end</span></span><br></pre></td></tr></table></figure>

<p>RUN commands</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl create -f replicaset-definition.yml</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get replicaset</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl get pods</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete rs myapp-replicaset</span></span><br><span class="line">or</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete replicaset myapp-replicaset</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl edit rs myapp-replicaset</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl delete pod [pod_name]</span></span><br></pre></td></tr></table></figure>
<img src="/2024/06/01/Kubernetes/Kubernetes-ReplicationController-vs-ReplicaSet/ReplicaSet_commands.jpg" class="">

<h4 id="Scale"><a href="#Scale" class="headerlink" title="Scale"></a>Scale</h4><p>📌 There are also options available for automatically scaling the ReplicaSet based on load!</p>
<ol>
<li><p>Method 1: Modify the number of <code>replicas</code> in <code>replicaset-definition.yml</code> and run the following command.</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl replace -f replicaset-definition.yml</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>Method 2: Run scale up&#x2F;down command</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale --replicas=6 -f replicaset-definition.yml</span></span><br><span class="line"></span><br><span class="line">or</span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale --replicas=6 [<span class="built_in">type</span>] [name]</span></span><br><span class="line"><span class="meta prompt_">$ </span><span class="language-bash">kubectl scale --replicas=6 replicaset myapp-replicaset</span></span><br></pre></td></tr></table></figure></li>
</ol>
<hr>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/">ReplicationController</a></li>
<li><a href="https://kubernetes.io/docs/concepts/workloads/controllers/replicaset/">ReplicaSet</a></li>
<li><a href="https://hackmd.io/@CynthiaChuang/Kubernetes-for-the-Absolute-Beginners-02">【K8S Beginners 筆記】CH 4~6 PODs, YAML, ReplicaSet and Deployments</a></li>
</ul>
]]></content>
      <categories>
        <category>Kubernetes</category>
      </categories>
      <tags>
        <tag>觀念解說</tag>
        <tag>Concepts</tag>
        <tag>ReplicationController</tag>
        <tag>ReplicaSet</tag>
      </tags>
  </entry>
</search>
